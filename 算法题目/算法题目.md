# 算法题目

## 数组

### 二分法找元素

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

```cpp
#include <vector>

class Solution
{
public:
    int search(std::vector<int> &nums, int target)
    {
        int left = 0;
        int right = nums.size() - 1;
        while (left <= right)//
        {
            int middle = (left + right) / 2;
            if (nums[middle] < target)
                left = middle + 1;
            else if (nums[middle] > target)
                right = middle - 1;
            else
                return middle;
        }
        return -1;
    }
};
```

**思路**：关注自己选取的区间，如果是左闭右闭那么while的循环条件取等不会没有意义，可以继续下去，给左右顶点赋值的时候因为两边都能取到所以都是+1或者-1操作。

### 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。*

*假设 nums 中不等于 val 的元素数量为 k，要通过此题，您需要执行以下操作：*

更改 nums 数组，使 nums 的前 k 个元素包含不等于 val 的元素。nums 的其余元素和 nums 的大小并不重要。

*返回 k。*

```cpp
#include <vector>
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size();fastIndex++){
            if(nums[fastIndex]!=val){
                nums[slowIndex] = nums[fastIndex];
                slowIndex++;
            }
        } 
        return slowIndex;
    }
};
```

**思路：**双指针（快慢指针法）

### 长度最小的子数组

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int result = INT32_MAX;
        int i = 0;
        int sum = 0;
        int sub = 0;
        for (int j = 0; j < nums.size();j++){
            sum += nums[j];
            while(sum>=target){
                sub = j - i + 1;
                result = result < sub ? result : sub;
                sum -= nums[i++];

            }
        }
        return result == INT32_MAX ? 0 : result;
    }
};
```

思路：**滑动窗口**，将j作为自区间的末尾循环遍历整个数组就只需要遍历一遍。

### 螺旋矩阵

给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        int i,j;
        int loop = n / 2;
        vector<vector<int>> nums(n, vector<int>(n, 0));
        int startx = 0, starty = 0, offset = 1, count = 1;
        while(loop--){
            for (j=starty; j < n - offset;j++){
                nums[startx][j] = count++;
            } // j=n-offset;
            for (i = startx; i < n - offset;i++){
                nums[i][j] = count++;
            }
            for (; j > starty; j--)
            {
                nums[i][j] = count++;
            }
            for (; i > startx; i--)
            {
                nums[i][j] = count++;
            }
            startx++;
            starty++;
            offset++;
        }
        if(n%2==1){
            nums[startx][starty] = count;
        }
        return nums;
    }
};
```

思路：每一圈都以一个左闭右开的区间进行打印，确保一致性。边界情况处理：中心位置元素单独讨论。

知识点：**vector初始化方式**：

```cpp
//初始化一个size为0的vector
vector<int> abc;
//初始化size,但每个元素值为默认值
vector<int> abc(10);    //初始化了10个默认值为0的元素
//初始化size,并且设置初始值
vector<int> cde(10，1);    //初始化了10个值为1的元素

int a[5] = {1,2,3,4,5};
//通过数组a的地址初始化，注意地址是从0到5（左闭右开区间）右开！！！！
vector<int> b(a, a+5);实际上是迭代器初始化

vector<int> a(5,1);
//通过a初始化
vector<int> b(a);拷贝初始化

```



## 链表

### 移除链表元素

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

```cpp
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode *dummyHead = new ListNode(0);//创建新链表的方式
        dummyHead->next = head;
        ListNode *cur = dummyHead;
        while (cur->next != nullptr ){
            if(cur->next->val==val){
                ListNode *tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;
            }else{
                cur = cur->next;
            }
        }
        ListNode* head1 = dummyHead->next;
        delete dummyHead;//手动释放内存
        return head1;
    }
};
```

思路：特殊情况是head位置，那么为了统一操作引入**虚拟头部**。要删除某个接待你就必须把操作的节点设置为该节点的上一个节点。



### 设计链表

[707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/description/)

```cpp
class MyLinkedList
{
public:
    MyLinkedList()
    {
        dummyHead = new ListNode(0);
        size = 0;
    }

    int get(int index)
    {
        if (index > (size - 1) || index < 0)
        {
            return -1;
        }
        ListNode *cur = dummyHead->next;
        while (index--)
        {
            cur = cur->next;
        }
        return cur->val;
    }

    void addAtHead(int val)
    {
        ListNode *newnode = new ListNode(val);
        newnode->next = dummyHead->next;
        dummyHead->next = newnode;
        size++;
    }

    void addAtTail(int val)
    {
        ListNode *newnode = new ListNode(val);
        ListNode *cur = dummyHead;
        while (cur->next != nullptr)
        {
            cur = cur->next;
        }
        cur->next = newnode;
        size++;
    }

    void addAtIndex(int index, int val)
    {
        if (index > (size) || index < 0)
        {
            return;
        }
        ListNode *newnode = new ListNode(val);
        ListNode *cur = dummyHead;
        while (index--) // 找到第index节点的写法
        {
            cur = cur->next; // 第零个结点cur->next指向的就是我们要的第零个，能保证cur是我们要插入的钱一个位置
        }
        newnode->next = cur->next;
        cur->next = newnode;
        size++;
    }

    void deleteAtIndex(int index)
    {
        if (index > (size) || index < 0)
        {
            return;
        }
        ListNode *cur = dummyHead; // 直到前一个节点的指针才能删掉这个节点。
        while (index--)
        {
            cur = cur->next;
        }
        ListNode *tmp = cur->next;
        cur->next = cur->next->next;
        delete tmp;
        size--;
    }

private:
    int size;
    ListNode *dummyHead;
};
```

### 



### 反转链表

https://leetcode.cn/problems/reverse-linked-list/submissions/563082122/

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

1. 常规双指针法

```cpp
class Solution
{
public:
    ListNode *reverseList(ListNode *head)
    {
        ListNode *cur = head;
        ListNode *pre = nullptr;
        ListNode *temp;
        while (cur)
        { // cur是null的时候就不需要再让cur的next指向pre
            temp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = temp; // 注意顺序
        }
        return pre;
    }
};
```

思路：让指针的方向翻一翻。由于是单向链表所以要格外注意赋值顺序和增加临时指针。

2. 递归法

```cpp
class Solution
{
public:
    ListNode *reverse(ListNode *pre, ListNode *cur)
    {
        if (cur == nullptr)
            return pre;
        ListNode *temp = cur->next;
        cur->next = pre;
        reverse(cur, temp);//pre=cur;cur=temp;
    }
    ListNode *reverseList(ListNode *head)
    {

        return reverse(nullptr, head);
    }
};
```

思路：递归里面套函数的时候可以对照正常写法的变量转化

### 删除倒数第n个节点

[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/)

```cpp
class Solution
{
public:
    ListNode *removeNthFromEnd(ListNode *head, int n)
    {
        ListNode *dummyhead = new ListNode(0);
        dummyhead->next = head;
        ListNode *slow = dummyhead;
        ListNode *fast = dummyhead;
        n++; // 防止越界，让fast走n+1步
        while (n-- && fast != nullptr)
            fast = fast->next;
        while (fast != nullptr)
        {
            fast = fast->next;
            slow = slow->next;
        }
        slow->next = slow->next->next;
        return dummyhead->next;
    }
};
```

思路：双指针法（快慢指针帮助定位）。让fast走n+1步，慢指针再跟着快指针走到null时，慢指针就就能指向倒数第n个节点的上一个节点。





### 环形链表

[142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/description/)

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

```cpp
        ListNode *fast = head;
        ListNode *slow = head;
        while (fast!=nullptr&&fast->next!=nullptr)
        {
            fast = fast->next->next;
            slow = slow->next;
            if(fast==slow){
                ListNode* index1 = fast;
                ListNode *index2 = head;
                while(index1!=index2){
                    index1 = index1->next;
                    index2 = index2->next;

                }
                return index1;
            }
        }
        return nullptr;
```

思路：双指针，快指针比慢指针多走一步就不会跳过慢指针，两者如果相遇就说明有环存在。根据公式推导，当快指针与慢指针相遇，刚好就在环的起点。





## 哈希表

哈希表常用于给你有一个元素判断在集合里是否出现过

1. 数组：数值不是很大
2. set：数值也不是很大但是数值很分散；数据相对比较大
3. map：适用于需要考虑下标

### 有效的字母异位词

[242. 有效的字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-anagram/description/)

给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的 

字母异位词。

```
输入: s = "anagram", t = "nagaram"
输出: true
```

```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        int harsh[26] = {0};
        for (int i = 0; i < s.size(); i++)
        {
            harsh[s[i] - 'a']++;
        }
        for (int i = 0; i < t.size(); i++)
        {
            harsh[t[i] - 'a']--;
        }
        for (int i = 0; i < 26; i++)
        {
            if(harsh[i]!=0)
                return false;
        }
        return true;//写在最外面
        }
};
```

思路：因为规定了小写字母，他们的ASCII码都是连续的，所以可考虑用数组来记录。把字符映射到数组哈希表的索引上，遍历s时先填入，遍历t时删除，如果最后哈希表里面出现不是0的元素就不是字母异位词。

### 两个数组的交集

[349. 两个数组的交集 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays/description/)

给定两个数组 `nums1` 和 `nums2` ，返回它们的交集

 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。

1. 用set：不确定数据多大

   问题：每放入一个值就要进行哈希运算对应一个内存空间同时是还要开辟一个新空间

```cpp
class Solution
{
public:
    vector<int> intersection(vector<int> &nums1, vector<int> &nums2)
    {
        unordered_set<int> result;
        unordered_set<int> nums_set(nums1.begin(), nums1.end());
        for (int num:nums2){
            if(nums_set.find(num) !=nums_set.end()){
                result.insert(num);
            }
        }
        return vector<int>(result.begin(), result.end());
    }
};

```

**知识点**：

set（include<set>）

**插入元素**：使用 `insert()` 方法。`set` 会自动排序并去重。

**遍历元素**：可以用范围for循环或迭代器。

**查找元素**：使用 `find()` 方法，如果找到则返回元素的迭代器，否则返回 `set.end()`。

> set.end()主要用于表示超过容器范围的一个位置

**删除元素**：使用 `erase()` 方法。

**初始化**：

```cpp
std::set<int> mySet = {10, 20, 30, 40};
 std::set<int> mySet(vec.begin(), vec.end());//用迭代器范围
std::set<int> set2(set1);//拷貝
std::set<int> set2(std::move(set1));//移动拷贝
std::set<int> mySet(arr, arr + 4);//数组迭代器
```

**空集初始化**：`std::set<int> mySet;`

**`initializer_list` 初始化**：`std::set<int> mySet = {10, 20, 30};`

**通过迭代器范围初始化**：`std::set<int> mySet(vec.begin(), vec.end());`

**拷贝构造初始化**：`std::set<int> set2(set1);`

**移动构造初始化**：`std::set<int> set2(std::move(set1));`

**通过数组初始化**：`std::set<int> mySet(arr, arr + size);`

2. 用数组：有数据大小<1000的规定

   直接用下标来做哈希映射

```cpp
//用数组，
class Solution
{
public:
    vector<int> intersection(vector<int> &nums1, vector<int> &nums2)
    {
        unordered_set<int> result;
        int harsh[1005] = {0};
        for (int i = 0; i < nums1.size(); i++)
        {
            harsh[nums1[i]]=1;
        }
                for (int i = 0; i < nums2.size(); i++)
        {
            if(harsh[nums2[i]]==1){
                result.insert(nums2[i]);
            };
        }
        
        return vector<int>(result.begin(), result.end());
    }
};
```



### 两数之和

[1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/submissions/563762743/)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        std::unordered_map<int, int> map;
        for (int i = 0; i < nums.size(); i++)
        {

            auto iter = map.find(target - nums[i]);
            if(iter!=map.end()){
                return {iter->second, i};
            }
            map.insert(pair<int, int>(nums[i], i));
        }
        return {};
    }
};
```

思路：每遍历一个元素都要看看另一个数是不是已经被遍历过了，所以需要有一个容器存放遍历过的数。并且同时需要知道元素和下标，通过元素找下标，用map将元素值作为key，查找方便，将下标作为value。用unorderedmap复杂度最低。



**知识点**：`std::map` 中的每个元素实际上是一个 `std::pair`，其中包含两个部分：

1. `first` 表示 **键**（key）。
2. `second` 表示 **值**（value）。

假设你有一个指向 `std::map` 元素的迭代器（如 `auto it`），使用 `it->first` 可以访问这个键值对的键，`it->second` 可以访问它的值。

1. **`std::map` 初始化方式**

1.1. **默认构造函数**

创建一个空的 `std::map`：

```
std::map<int, std::string> myMap;
```

1.2. **初始化列表**

使用键值对列表来初始化 `std::map`：

```
std::map<int, std::string> myMap = {
    {1, "one"},
    {2, "two"},
    {3, "three"}
};
```

1.3. **拷贝构造函数**

通过另一个 `std::map` 初始化：

```
std::map<int, std::string> copyMap(myMap);
```

1.4. **范围初始化**

使用两个迭代器初始化 `std::map`：

```
std::vector<std::pair<int, std::string>> vec = {
    {1, "one"}, {2, "two"}, {3, "three"}
};
std::map<int, std::string> myMap(vec.begin(), vec.end());
```

------

2. **常用函数**

2.1. **插入元素**

2.1.1. **使用 `operator[]` 插入或更新元素**

使用 `[]` 可以直接插入或更新一个键值对：

```
myMap[4] = "four";  // 插入键为4，值为"four"的键值对
myMap[2] = "updated";  // 更新键为2的值
```

2.1.2. **使用 `insert()` 插入元素**

通过 `insert()` 插入键值对：insert（pair<T,T>(i,j)）

```
myMap.insert({5, "five"});
auto result = myMap.insert({2, "two"});  // 如果键2已存在，插入失败,因为key不可重复，不可修改
```

2.2. **查找元素**

2.2.1. **使用 `find()` 查找元素**

返回指向指定键的迭代器。如果未找到，返回 `end()`：

```cpp
auto it = myMap.find(2);//找键值为2
if (it != myMap.end()) {
    std::cout << "Found: " << it->first << ": " << it->second << std::endl;
}
```

2.2.2. **使用 `count()` 判断键是否存在**

`count()` 返回键的出现次数（对于 `std::map`，返回值只能是 0 或 1）：

```
if (myMap.count(2)) {
    std::cout << "Key 2 exists" << std::endl;
}
```

2.3. **删除元素**

2.3.1. **使用 `erase()` 删除指定键的元素**

可以通过键或迭代器删除元素：

```
myMap.erase(2);  // 删除键为2的元素
```

2.3.2. **使用 `clear()` 清空整个 `map`**

清空所有元素：

```
myMap.clear();  // 清空 map
```

2.4. **遍历元素**

2.4.1. **使用范围 `for` 循环遍历**

```
for (const auto& pair : myMap) {
    std::cout << pair.first << ": " << pair.second << std::endl;
}
```

2.4.2. **使用迭代器遍历**

```
for (auto it = myMap.begin(); it != myMap.end(); ++it) {
    std::cout << it->first << ": " << it->second << std::endl;
}
```

2.5. **获取 `map` 的大小和状态**

2.5.1. **使用 `size()` 获取元素个数**

```
std::cout << "Size of the map: " << myMap.size() << std::endl;
```

2.5.2. **使用 `empty()` 检查 `map` 是否为空**

```
cpp复制代码if (myMap.empty()) {
    std::cout << "The map is empty" << std::endl;
}
```

2.6. **其他函数**

2.6.1. **访问第一个和最后一个元素**

- `begin()` 返回指向第一个元素的迭代器：

  ```
  cpp复制代码auto it = myMap.begin();
  std::cout << it->first << ": " << it->second << std::endl;
  ```

- `end()` 返回指向容器末尾之后的迭代器，不能解引用，用于判断遍历结束。

2.6.2. **自定义排序**

`std::map` 默认按 默认按键的升序排序，但可以自定义排序规则：

```cpp
struct CompareDesc {
    bool operator()(const int& lhs, const int& rhs) const {
        return lhs > rhs;  // 按降序排列
    }
};
std::map<int, std::string, CompareDesc> myMap = {{1, "one"}, {2, "two"}};
//或者
    std::map<int, std::string, std::function<bool(int, int)>> myMap([](int lhs, int rhs) { return lhs > rhs; } ） // 降序std::function：用作 std::map 的第三个模板参数，用于接收 Lambda 表达式作为比较函数。

```



### 三数之和

[15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/description/)

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

```cpp
class Solution
{
public:
    vector<vector<int>> threeSum(vector<int> &nums)
    {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i++)
        {
            if (nums[i] > 0) // 三元组里面最小的数都大于0了不行
                return result;
            // 三元素里面的值可以相等，找前面有没有相等的元素，前面相等说明前面和自己相等的这个首元素已经做好了找三元组的过程，这时候跳过没有问题
            if (i > 0 && nums[i] == nums[i - 1])
                continue;
            int left = i + 1;
            int right = nums.size() - 1;
            while (right > left) // 如果left right重复逻辑放在这里面可能直接导致right<=left从而漏掉{000}
            {
                if (nums[i] + nums[left] + nums[right] > 0)
                    right--;
                else if (nums[i] + nums[left] + nums[right] < 0)
                    left++;
                else
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                while (right > left && nums[right] == nums[right - 1])
                    right--;
                while (right > left && nums[left] == nums[left + 1])
                    left++;
//收获一个结果之后，双指针同时收缩
                left++;
                right--;
            }
        }
        return result;
    }
};
```

思路：这里用哈希表很难。用双指针法：先排序，后确定左右区间再不断缩小。

关键是去重操作

### 四数之和

[18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/description/)

```cpp
class Solution
{
public:
    vector<vector<int>> fourSum(vector<int> &nums, int target)
    {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int k = 0; k < nums.size(); k++)
        { // 剪枝
            if (nums[k] > target && nums[k] > 0 && target > 0)
            {
                break;
            }
            if (k > 0 && nums[k] == nums[k - 1])
                continue;
            for (int i = k + 1; i < nums.size(); i++)
            {
                if (i > k + 1 && nums[i] == nums[i - 1])
                    continue;
                int left = i + 1;
                int right = nums.size() - 1;
                while (right > left)
                {
                    if (nums[k] + nums[i] + nums[left] + nums[right] > target)
                        right--;
                    else if (nums[k] + nums[i] + nums[left] + nums[right] < target)
                        left++;
                    else
                    {
                        result.push_back(vector<int>{nums[k], nums[i], nums[left], nums[right]});
                        while (right > left && nums[right] == nums[right - 1])
                            right--;
                        while (right > left && nums[left] == nums[left + 1])
                            left++;
                        right--;
                        left++;
                    }
                }
            }
        }
        return result;
    }
};
```

思路：还是双指针，不过最外层再套一层循环以及剪枝操作和去重操作





## 字符串

### 反转字符串

[344. 反转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string/submissions/564907863/)

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。

不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。

```cpp
class Solution
{
public:
    void reverseString(vector<char> &s)
    {
        int len = s.size();
        for (int i = 0, j = len - 1; i < len / 2; i++, j--)
        {
            swap(s[i], s[j]);
        }
    }
};
```

思路：双指针法

知识点：

1. std::reverse（迭代器1，迭代器2）头文件algorithm

   ```cpp
   std::reverse(arr + 1, arr + 4);
   ```

   

2. std::swap头文件iostream

   ```cpp
   #include <utility>
   //交换容器值
       std::vector<int> vec1 = {1, 2, 3};
       std::vector<int> vec2 = {4, 5, 6};
       std::swap(vec1, vec2);
   
   // 交换 a 和 b 的值
   	int a = 5, b = 10;
       std::swap(a, b);
   ```

   

### 反转字符串2

[541. 反转字符串 II - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string-ii/description/)

给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样

```cpp
class Solution
{
public:
    string reverseStr(string s, int k)
    {
        for (int i = 0; i < s.size(); i+=2*k)
        {
            if(i+k<=s.size())

            {std::reverse(s.begin()+i,s.begin()+i+k);//左闭右开
                continue;
            }
            std::reverse(s.begin()+i, s.begin()+s.size());
        }
        return s;
        }
};
```

思路：一段一段处理的时候做循环可以一段一段地跳过去。后面能找到k个就继续循环，不足k个就做到结尾结束。

### 反转字符串里面的单词

[151. 反转字符串中的单词 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-words-in-a-string/description/)

给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。

**单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。

返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。

**注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

```cpp
class Solution
{
public:
    void removeextra(string &s)
    {
        int slow = 0;
        int fast=0;
        while (s.size() > 0 && fast < s.size()&&s[fast] == ' ')
        {
            fast++;
        } // 去掉字符串前面的空格

        for (; fast < s.size(); fast++) // 此时一定是进入了第一个字母
        {
            if (fast - 1 > 0 && s[fast - 1] == s[fast] && s[fast] == ' ')
            {
                continue; // 去除中间冗余空格
            }
            else
            {
                s[slow] = s[fast];
                slow++;
            }

        } // 去除结尾的空格
        if (slow - 1 > 0 && s[slow - 1] == ' ')
        {
            s.resize(slow - 1);
        }
        else
        {
            s.resize(slow);
        }
    }
    void reverse(string &s, int start, int end)
    {
        for (int i = start, j = end; i < j; i++, j--)
        {
            std::swap(s[i], s[j]);
        }
    }
    string reverseWords(string s)
    {
        removeextra(s);
        reverse(s, 0, s.size() - 1);
        int start = 0;
        int end = 0;
        bool entry = false; // 是否进入了单词。
        for (int i = 0; i < s.size(); i++)
        {
            if (!entry || (s[i] != ' ' && s[i - 1] == ' '))
            {
                start = i;
                entry = true;
            }
            if (entry && s[i] == ' ' && s[i - 1] != ' ')
            {
                end = i - 1;
                entry = false;
                reverse(s, start, end);

            } // 最后一个单词
            if (entry && (i == (s.size() - 1)) && s[i] != ' ')
            {
                end = i;
                entry = false;
                reverse(s, start, end);
            }
        }
        return s;
    }
};
```

思路：整体思路是先全体翻转再局部反转。难点在于如何去除冗余的空格。

知识点：

函数原型：

```
void resize (size_type n);
void resize (size_type n, const value_type& val);
```

 作用：
改变容器的大小，使得其包含n个元素。常见三种用法。

1、如果n小于当前的容器大小，那么则保留容器的前n个元素，去除（erasing）超过的部分。

2、如果n大于当前的容器大小，则通过在容器结尾插入(inserting)适合数量的元素使得整个容器大小达到n。且如果给出val，插入的新元素全为val，否则，执行默认构造函数。

3、如果n大于当前容器的容量（capacity）时，则会自动重新分配一个存储空间。



### 使用KMP匹配字符串

https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。

```cpp
class Solution {
public:
    void getNext(int *next, const string &s)
    {//后缀表建立（不做整体减一）
        next[0] = 0;
        int j = 0;
        for (int i = 1; i < s.size(); i++)
        {
            while (j > 0 && s[i] != s[j])
            {
                j = next[j - 1];
            }
            if (s[i] == s[j])
            {
                j++;
            }
            next[i] = j;
        }
    }
    int strStr(string haystack, std::string needle) {
        if(needle.size()==0){
            return false;
        }
        int next[needle.size()];
        getNext(next, needle);
        int j = 0;
        for (int i = 0; i < haystack.size(); i++)
        {
            while (j > 0&&haystack[i]!=needle[j]){
                j=next[j-1];
            }
            if(haystack[i]==needle[j])
                j++;
            if(j==needle.size())
                return (i - needle.size() + 1);
            
        }return -1;
        
  class Solution {
public:
    void getNext(int *next, const string &s)
    {//后缀表建立（做整体减一）
        
        int j = -1;
        next[0]=j;
        for (int i = 1; i < s.size(); i++)
        {
            while(j>=0&&s[i]!=s[j+1])
                j=next[j];
            if(s[i]==t[j+1])
                j++;
            next[i]=j;
        }
    }
    int strStr(string haystack, std::string needle) {
        if(needle.size()==0){
            return false;
        }
        int next[needle.size()];
        getNext(next, needle);
        int j = -1;
        for (int i = 0; i < haystack.size(); i++)
        {
            while (j >= 0&&haystack[i]!=needle[j+1]){
                j=next[j];
            }
            if(haystack[i]==needle[j+1])
                j++;
            if(j+1==needle.size())
                return (i - needle.size() + 1);
            
        }return -1;
```

思路：从头到尾找对应的字母，如果一旦有字母不对，先返回前一位取得公共子字符串的长度，再s[i]索引到那个位置和原字符串的位置比较（因为此时回到的那个位置也一定在原字符串中匹配好了！）就返回目标字符串里公共前后缀的后一位开始查询。（有效率，不会漏）

### 找到重复的子字符串

[459. 重复的子字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/repeated-substring-pattern/description/)

给定一个非空的字符串 `s` ，检查是否可以通过由它的一个子串重复多次构成。

```cpp
class Solution
{
public:
    void getNext(int *next, const string &s)
    {//后缀表建立
        next[0] = 0;
        int j = 0;
        for (int i = 1; i < s.size(); i++)
        {
            while (j > 0 && s[i] != s[j])
            {
                j = next[j - 1];
            }
            if (s[i] == s[j])
            {
                j++;
            }
            next[i] = j;
        }
    }
    bool repeatedSubstringPattern(string s)
    {

        if (s.size() == 0)
        {
            return false;}

            int next[s.size()];
            getNext(next, s);
            int len = s.size();
            if (next[len - 1] != 0 && len % (len - (next[len - 1])) == 0){
                return true;
        }
        return false;
    }
};
```

思路：KMP算法。j相当于前缀字符串的末尾，i相当于后缀字符串的末尾。要找到重复的子字符串，先找到最长相等前后缀长度，再将数组长度减去这个值，结果如果能被整个字符串整除就是子字符串。

## 栈与队列

### 用栈组成的队列

[232. 用栈实现队列 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-queue-using-stacks/description/)

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：

- `void push(int x)` 将元素 x 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`

**说明：**

- 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

```cpp
class MyQueue
{
public:
    stack<int> stIn;
    stack<int> stOut;
    MyQueue()
    {
    }

    void push(int x)
    {
        stIn.push(x);
    }

    int pop()
    {
        if (stOut.empty())
        {
            while (!stIn.empty())
            {
                stOut.push(stIn.top());
                stIn.pop();
            }
        }
        int result = stOut.top();
        stOut.pop();
        return result;
    }

    int peek()
    {
        int res = this->pop();
        stOut.push(res);
        return res;
    }

    bool empty()
    {
        return stIn.empty() && stOut.empty();
    }
};
```

思路：用两个栈调整出栈顺序。注意函数的复用。

知识点：

```cpp
void stack.pop();
int stack.top();//注意两者的返回类型
void stack.push;
```

### 用队列实现栈

[225. 用队列实现栈 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-stack-using-queues/description/)

使用队列实现栈的下列操作：

- push(x) -- 元素 x 入栈
- pop() -- 移除栈顶元素
- top() -- 获取栈顶元素
- empty() -- 返回栈是否为空

注意:

- 你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。

- 你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。

- 你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。

  ```cpp
  #include <stack>
  #include <queue>
  template <typename T>
  using stack = std::stack<T>;
  template <typename T>
  using queue = std::queue<T>;
  // 用栈实现队列
  class MyQueue
  {
  public:
      stack<int> stIn;
      stack<int> stOut;
      MyQueue()
      {
      }
  
      void push(int x)
      {
          stIn.push(x);
      }
  
      int pop()
      {
          if (stOut.empty())
          {
              while (!stIn.empty())
              {
                  stOut.push(stIn.top());
                  stIn.pop();
              }
          }
          int result = stOut.top();
          stOut.pop();
          return result;
      }
  
      int peek()
      {
          int res = this->pop();
          stOut.push(res);
          return res;
      }
  
      bool empty()
      {
          return stIn.empty() && stOut.empty();
      }
  };
  
  /**
   * Your MyQueue object will be instantiated and called as such:
   * MyQueue* obj = new MyQueue();
   * obj->push(x);
   * int param_2 = obj->pop();
   * int param_3 = obj->peek();
   * bool param_4 = obj->empty();
   */
  
  //用队列实现栈
  class MyStack {
  public:
      queue<int> que;
      MyStack() {
  
      }
      
      void push(int x) {
          que.push(x);
      }
      
      int pop() {
          int size = que.size();
          size--;
  
          while(size--){
              que.push(que.front());
              que.pop();
          }
          int result = que.front();
          que.pop();
          return result;
      }
      
      int top() {
          return que.back();
      }
      
      bool empty() {
          return que.empty();
      }
  };
  
  /**
   * Your MyStack object will be instantiated and called as such:
   * MyStack* obj = new MyStack();
   * obj->push(x);
   * int param_2 = obj->pop();
   * int param_3 = obj->top();
   * bool param_4 = obj->empty();
   */
  ```

  

思路：要取出队列的最后一个元素，就前面所有元素都移到它后面。

### 匹配括号

[20. 有效的括号 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-parentheses/description/)

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。

2. 左括号必须以正确的顺序闭合。

3. 每个右括号都有一个对应的相同类型的左括号。

   ```cpp
   class Solution {
   public:
       bool isValid(string s) {
           stack<int> st;
           if(s.size()%2!=0)
               return false;
       for (int i = 0; i < s.size(); i++)
       {
           if(s[i]=='(')
               st.push(')');
           else if(s[i]=='[')
               st.push(']');
           else if(s[i]=='{')
               st.push('}');
               else if(st.empty()||st.top()!=s[i])
                   return false;
               else
                   st.pop();
   
   
   
   
   
   
       }
       return (st.empty());
       }
   };
   ```

思路：

三种不匹配状态：

1. 左括号多
2. 右括号多
3. 左右括号不是同一类型

将左括号记作右括号进入栈方便比较消去。

剪枝：size为奇数肯定不可能。

### 逆波兰表达式求值

[150. 逆波兰表达式求值 - 力扣（LeetCode）](https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/)

根据 逆波兰表示法，求表达式的值。

有效的运算符包括 + , - , * , / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

说明：

整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

示例 1：

- 输入: ["2", "1", "+", "3", " * "]
- 输出: 9
- 解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9

示例 2：

- 输入: ["4", "13", "5", "/", "+"]
- 输出: 6
- 解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6

示例 3：

- 输入: ["10", "6", "9", "3", "+", "-11", " * ", "/", " * ", "17", "+", "5", "+"]
- 输出: 22
- 解释:该算式转化为常见的中缀算术表达式为：

```cpp
class Solution
{
public:
    int evalRPN(vector<string> &tokens)
    {
        stack<int> st;
        for (int i = 0; i < tokens.size(); i++)
        {
            if(tokens[i]=="+"||tokens[i]=="-"||tokens[i]=="*"||tokens[i]=="/"){
            int nums1 = st.top();
            st.pop();
            int nums2 = st.top();
            st.pop();
            if (tokens[i] == "+")
            {
                st.push(nums2 + nums1);
            }
            if (tokens[i] == "-")
            {
                st.push(nums2 - nums1);
            }
            if (tokens[i] == "/")
            {
                st.push(nums2 / nums1);
            }
            if (tokens[i] == "*")
            {
                st.push(nums2 * nums1);
            }}
            else{
                st.push(stoi(tokens[i]));
            }
        }
        int res = st.top();
        st.pop();//释放内存
        return res;
    }
};
```

思路：采用二叉树的后序遍历。

### 滑动窗口最大值

[239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/description/)

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

 

**示例 1：**

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**示例 2：**

```
输入：nums = [1], k = 1
输出：[1]
```

 

**提示：**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`
- `1 <= k <= nums.length`

```cpp
class Solution
{
private:
    class Myqueue
    {
    public:
        deque<int> que;
        void pop(int val)
        {
            if (!que.empty() && val == que.front())
                que.pop_front();
        }
        void push(int val)
        {
            while (!que.empty() && val > que.back())
                que.pop_back();
            que.push_back(val);
        }
        int front()
        {
            return que.front();
        }
    };

public:
    vector<int>
    maxSlidingWindow(vector<int> &nums, int k)
    {
        Myqueue que;
        vector<int> result;
        for (int i = 0; i < k; i++)
        {
            que.push(nums[i]);
        }
        result.push_back(que.front());
        for (int i = k; i < nums.size(); i++)
        {
            que.pop(nums[i - k]); // 前一个窗口的首元素
            que.push(nums[i]);    // 后一个窗口的首元素
            result.push_back(que.front());
        }
        return result;
    }
};
```

思路：利用队列结构放入窗口，每滑动一次，首元素pop，push后一个元素，通过push的维护将最大值保留在首位。pop必须先确认栈的首元素是不是窗口的首元素。所以两个函数都要自己去定义，自己去设计自己需要的类。

### 前k个高频元素

[347. 前 K 个高频元素 - 力扣（LeetCode）](https://leetcode.cn/problems/top-k-frequent-elements/description/)

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

 

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2:**

```
输入: nums = [1], k = 1
输出: [1]
```

 

**提示：**

- `1 <= nums.length <= 105`
- `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
- 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

 

**进阶：**你所设计算法的时间复杂度 **必须** 优于 `O(n log n)` ，其中 `n` 是数组大小

```cpp

class Solution
{
public:
    class mycomparison
    {
    public:
        bool operator()(const pair<int, int> lhs, const pair<int, int> rhs)
        {
            return lhs.second > rhs.second;
        }
    };
    vector<int> topKFrequent(vector<int> &nums, int k)
    {
        unordered_map<int, int> map;
        for (int i = 0; i < nums.size(); i++)
        {
            map[nums[i]]++;
        }
        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;//初始化
        for (unordered_map<int, int>::iterator it = map.begin(); it != map.end(); it++)
        {
            pri_que.push(*it);//放元素
            if (pri_que.size() > k)
            {
                pri_que.pop();
            }} // 每次让出现频次小的数出去
            // 倒序遍历输出
            vector<int> result(k);
            for (int i = k - 1; i >= 0; i--)
            {
                result[i] = pri_que.top().first;
                pri_que.pop();
            }
            
        return result;
    }
};
```

知识点：

优先队列底层都是二叉树：、

父母比孩子小/大。

在C++中，`std::priority_queue` 的模板参数分为三个部分，分别是元素类型、底层容器类型和比较函数。我们来看一下以下代码的具体含义：

```cpp
std::priority_queue<int,std::vector<int>,std::greater<int>> min_pq>;//小顶栈
std::priority_queue<int> pq; // 大顶堆
```

**模板参数详解**

1. **第一个参数 `int`**：

   - 指定了优先队列中存储元素的类型。

2. **第二个参数 `std::vector<int>`**：

   - 这个参数指定了优先队列使用的底层容器类型。默认情况下，`std::priority_queue` 使用 `std::vector` 作为底层容器，因为 `std::vector` 提供了随机访问和动态扩展的能力，适合堆操作。

3. **第三个参数 `std::greater<int>`**：

   - 这个参数指定了优先队列中元素的比较方式。默认情况下，`std::priority_queue` 使用 `std::less`，也就是说它是一个最大堆，较大元素优先出队。

     

思路：

考虑用map，但是map储存之后再排序的时间复杂度是n*logn。但是不是每个元素都需要排序，只需要k个。考虑优先队列。

用大顶栈不方便维护k个元素（pop操作会把最大的给拿掉）

用小顶栈可以，但是最后要倒序输出。



## 二叉树

### 前中后序递归遍历

#### 前序

```cpp
class Solution
{
public:
    void traversal(TreeNode *cur, vector<int> &vec)
    {
        if (cur == NULL)
            return;
        vec.push_back(cur->val);//中
        traversal(cur->left,vec);//左
        traversal(cur->right,vec);//右
    }
    vector<int> preorderTraversal(TreeNode *root)
    {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```

#### 中序

```cpp
class Solution
{
public:
    void traversal(TreeNode *cur, vector<int> &vec)
    {
        if (cur == NULL)
            return;
        
        traversal(cur->left,vec);//左
        vec.push_back(cur->val);//中
        traversal(cur->right,vec);//右
    }
    vector<int> inorderTraversal(TreeNode *root)
    {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```

#### 后序

```cpp
class Solution
{
public:
    void traversal(TreeNode *cur, vector<int> &vec)
    {
        if (cur == NULL)
            return;
        
        traversal(cur->left,vec);
        
        traversal(cur->right,vec);
        vec.push_back(cur->val);
    }
    vector<int> postorderTraversal(TreeNode *root)
    {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```

### 前中后序的迭代遍历

前序

```cpp
class Solution
{
public:
    
    vector<int> postorderTraversal(TreeNode *root)
    {
        vector<int> result;
        stack<TreeNode *> st;
        st.push(root);
        TreeNode *node;
        while(!st.empty()){
            node = st.top();
            st.pop();
            if(node!=nullptr){
                result.push_back(node->val);//中
            }
            else{
                continue;
            }
            st.push(node->right);//右
            st.push(node->left);//左
        }
        return result;
    }
};
```

后序

```cpp
class Solution//后续遍历
{
public:
    
    vector<int> postorderTraversal(TreeNode *root)
    {
        vector<int> result;
        stack<TreeNode *> st;
        st.push(root);
        TreeNode *node;
        while(!st.empty()){
            node = st.top();
            st.pop();
            if(node!=nullptr){
                result.push_back(node->val);//中
            }
            else{
                continue;
            }
            
            st.push(node->left);//左
            st.push(node->right);//右
        }
        reverse(result.begin(),result.end());
        return result;
    }
};

```

中序

```cpp
class Solution // 中序
{
public:
    vector<int> inorderTraversal(TreeNode *root)
    {
        vector<int> result;
        stack<TreeNode *> st;
        TreeNode *cur = root;
        while (cur != nullptr || !st.empty())
        {
            if (cur != nullptr)
            {
                st.push(cur);
                cur = cur->left;
            }
            else
            {
                cur = st.top();
                st.pop();
                result.push_back(cur->val);
                cur = cur->right;
            }
        }
        return result;
    }
};
```

知识点：

vector的reverse函数：

include<algorithm>

reverse.(it1,it2)

eg:reverse(vector.begin(),vector.end())

### 层序遍历

[102. 二叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

```cpp
class Solution
{
public:
    vector<vector<int>> levelOrder(TreeNode *root)
    {
        queue<TreeNode *> que;
        TreeNode *node;
        vector<vector<int>> result;
        if (root != NULL)
            que.push(root);
        while (!que.empty())
        {
            int size = que.size(); // 不记录的话容易和下一层的元素一起弹出来，这是控制弹出数目
            vector<int> vec;
            while (size--)//在循环里que的size是不断变化的
            {
                node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left)
                    que.push(node->left);
                if (node->right)
                    que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

思路：使用队列，一层一层出来，再把左右孩子分别放入，重要的是要把每一层的个数记录。

### 翻转二叉树

[226. 翻转二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/invert-binary-tree/description/)

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

```cpp
class Solution
{
public:
    TreeNode *invertTree(TreeNode *root)
    {
        if (root == nullptr) // root是指操作的变量
            return root;
        swap(root->left, root->right);//中
        invertTree(root->left);//左
        invertTree(root->right);//右
        
        return root;
    }
};
```

思路：使用前序遍历和后序遍历比较方便，使用中序遍历，交换之后，左右子树位置变换，invertTree（root->right）相当于重复操作。

### 对称二叉树

[101. 对称二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/symmetric-tree/description/)

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

```cpp
class Solution
{
public:
    bool compare(TreeNode *left, TreeNode *right)
    {
        if (left == nullptr && right != nullptr)
            return false;
        else if (left != nullptr && right == nullptr)
            return false;
        else if (left == nullptr && right == nullptr) // 第二层就是两个都为空就可以直接返回。
            // 剩下的内部节点由bool inside = compare(left->right, right->left)检查
            // 到最终两个节点都是空就直接返回true。
            return true;
        else if (left->val != right->val)
            return false;
        bool outside = compare(left->left, right->right);
        bool inside = compare(left->right, right->left);
        bool result = outside & inside;
        return result;
    };

    bool isSymmetric(TreeNode *root)
    {
        if (root == nullptr)
            return true;
        return compare(root->left, root->right);
    }
};
```

思路：

1. 判断对称，外侧相等，内侧相等。
2. 遍历方式，对于每两个节点，外侧内测子孩子都相等，就回到这两个节点本身。是左（外侧）右（内侧）中的后序遍历方式。

### 二叉树的最大深度

https://leetcode.cn/problems/maximum-depth-of-binary-tree/

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

```cpp
class Solution
{
public:
    int getheight(TreeNode *node)
    {
        if (node == nullptr)
        {
            return 0;
        }
        int leftheight = getheight(node->left);

        int rightheight = getheight(node->right);
        int height = max(leftheight, rightheight) + 1;
        return height;
    }
    int maxDepth(TreeNode *root)
    {
        return getheight(root);
    }
```

思路：后序遍历



### 最小深度

[111. 二叉树的最小深度 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。



1. 递归法（后序遍历求高度）

```cpp
class Solution
{
public:
int getheight(TreeNode *node)
    {
        if (node == nullptr)
        {
            return 0;
        }
        int leftheight = getheight(node->left);

        int rightheight = getheight(node->right);
        if (node->left==nullptr&&node->right!=nullptr)
        {
            return 1 + rightheight;
        }
        else if (node->left!=nullptr&&node->right==nullptr)
        {
           return 1 + leftheight;
        }
        else
            return min(leftheight, rightheight)+1;
    }
    int minDepth(TreeNode *root)
    {
        return getheight(root);
    }
};
```

思路：返回+1



2. 迭代法(层序遍历)

   ```cpp
   class Solution
   {
   public:
       int minDepth(TreeNode *root)
       {
           queue<TreeNode *> que;
           TreeNode *node;
           int depth = 0;
           int min_layer = INT_MAX;
           if (root != NULL)
               que.push(root);
           while (!que.empty())
           {
               int size = que.size(); // 不记录的话容易和下一层的元素一起弹出来，这是控制弹出数目
               vector<int> vec;
               depth++;
               while (size--) // 在循环里que的size是不断变化的
               {
                   node = que.front();
                   que.pop();
                   vec.push_back(node->val);
                   if (node->left)
                       que.push(node->left);
                   if (node->right)
                       que.push(node->right);
                   if (!node->right && !node->left)
                   {
                       return depth;
                   }
               }
           }
           return min_layer == INT_MAX ? 0 : min_layer;
       }
   };
   ```

   

### 平衡二叉树

[110. 平衡二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/balanced-binary-tree/description/)

```cpp
class Solution {
public:
int getHeight(TreeNode * node){
    if(node==nullptr){
        return 0;
    }
    int leftHeight = getHeight(node->left);
    if(leftHeight==-1)
        return -1;
    int rightHeight = getHeight(node->right);
    if(rightHeight==-1)
        return -1;

    return abs(leftHeight - rightHeight) > 1 ? -1 : 1 + max(leftHeight, rightHeight);
    
}
    bool isBalanced(TreeNode* root) {
        return getHeight(root) == -1 ? false : true;
    }
};

```

思路：还是通过计算每个节点的高度，做差，如果大于1就统一返回-1.

### 二叉树的所有路径

[257. 二叉树的所有路径 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-paths/description/)

```cpp
class Solution
{
public:
    void traversal(TreeNode *node, vector<int> &path, vector<string> &result)
    {
        path.push_back(node->val); // middle

        if (node->left == nullptr && node->right == nullptr)
        {
            string sPath;
            for (int i = 0; i < path.size() - 1; i++)
            {
                sPath += to_string(path[i]);
                sPath += "->";
            }
            sPath += to_string(path[path.size() - 1]);

            result.push_back(sPath);
        }
        if (node->left)
        {
            traversal(node->left, path, result);
            path.pop_back(); // 回溯
        }
        if (node->right)
        {
            traversal(node->right, path, result);
            path.pop_back(); // 回溯
        }
    };
    vector<string> binaryTreePaths(TreeNode *root)
    {
        vector<string> result;
        vector<int> path;
        if(root==nullptr)
            return result;
        traversal(root, path, result);
        return result;
    }
};
```

思路：采用前序遍历的方法递归深入，再一层一层往前回溯。

### 路径总和

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

[. 路径总和 - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum/)

```cpp
class Solution
{
public:
    bool traversal(TreeNode *node, int count)
    {
        if (node->left == nullptr && node->right == nullptr && count == 0)
            return true;
        if (node->left == nullptr && node->right == nullptr && count != 0)
            return false;
        if (node->left)
        {
            count -= node->left->val;
            if (traversal(node->left, count))
                return true;
            count += node->left->val; // 回溯
        }
        if (node->right)
        {
            count -= node->right->val;
            if (traversal(node->right, count))
                return true;
            count += node->right->val;
        }
        return false;
    }
    bool hasPathSum(TreeNode *root, int targetSum)
    {
        if (root == nullptr)
            return false;
        return traversal(root, targetSum - root->val);
    }
};
```

思路：和求路径一样要考虑回溯。然后要注意一旦有true了就层层返回true！同判断平衡二叉树那道题一样。

### 使用中序与后序遍历序列构造二叉树

[106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)

```cpp
class Solution {
public:
TreeNode* traversal(vector<int>& inorder,vector<int>& postorder){
if(postorder.size()==0)
    return NULL;
int rootvalue = postorder[postorder.size() - 1];//先找到根节点
TreeNode *root = new TreeNode(rootvalue);
if(postorder.size()==1)
    return root;
int index = 0;
for (index = 0; index< inorder.size(); index++)
{
   if(inorder[index]==rootvalue)
       break;
}//index定义在for循环外面来保存在中序数组中找到的中节点的位置
//用index切中序数组 得左中序和右中序
vector<int> leftInorder(inorder.begin(), inorder.begin() + index);
vector<int> rightInorder(inorder.begin() + index + 1, inorder.end());
//用中序数组里左中序数组大小切后序数组
postorder.resize(postorder.size() - 1);
vector<int> leftPostorder(postorder.begin() , postorder.begin()+leftInorder.size());
vector<int> rightPostorder(postorder.begin()+leftInorder.size(), postorder.end());

root->left = traversal(leftInorder,leftPostorder);
root->right = traversal(rightInorder,rightPostorder);
return root;
}
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return traversal(inorder, postorder);
    }
};
```







### 在二叉搜索树中寻找节点

[700. Search in a Binary Search Tree - 力扣（LeetCode）](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。

```cpp
class Solution//递归法
{
public:
    TreeNode *searchBST(TreeNode *root, int val)
    {
        if (root == NULL || root->val == val)
            return root;
        TreeNode *result = nullptr;
        if (val < root->val)
        {
            result = searchBST(root->left, val);
        }
        if (val > root->val)
        {
            result = searchBST(root->right, val);
        }
        return result;
    }
};
class Solution // 迭代法
{
public:
    TreeNode *searchBST(TreeNode *root, int val)
    {
        while (root != nullptr)
        {
            if (val < root->val)
            {
                root = root->left;
            }
            else if (val > root->val)
                root = root->right;
            else
                return root;
        }
        return nullptr;
    }
};
```

### 验证二叉搜索树

[98. 验证二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/validate-binary-search-tree/submissions/573902501/)

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左

  子树

  只包含

   小于 

  当前节点的数。

- 节点的右子树只包含 **大于** 当前节点的数。

- 所有左子树和右子树自身必须也是二叉搜索树。

- ```cpp
  // 验证二叉搜索树
  // 使用数组法
  
  class Solution
  {
  public:
      vector<int> result;
      bool isValidBST(TreeNode *root)
      {
  
          if (root == nullptr)
          {
              return true;
          }
          if (!isValidBST(root->left))
              return false;
          result.push_back(root->val);
          if (!isValidBST(root->right))
              return false;
          for (int i = 1; i < result.size(); i++)
          {
              if (result[i] <= result[i - 1])
              {
                  return false;
              }
          }
          return true;
      }
  };
  // 不使用数组
  class Solution
  {
  public:
      long long maxVal = LONG_MIN;
      bool isValidBST(TreeNode *root)
      {
          if (root == nullptr)
          {
              return true;
          }
          bool left = isValidBST(root->left);
          if (root->val > maxVal)
          {
              maxVal = root->val; // maxVal record the previous node's val,since the inorder ascendingue
          }
          else
              return false;
          bool right = isValidBST(root->right);
          return left && right;
      }
  };
  // 不使用额外变量的双指针法
  
  class Solution
  {
  public:
      TreeNode *pre = nullptr;
      bool isValidBST(TreeNode *root)
      {
          if (root == nullptr)
          {
              return true;
          }
          bool left = isValidBST(root->left);
          if (pre!= nullptr && root->val <= pre->val)
  
              return false;
          pre = root;//use pointer pre to record the previous node
          bool right = isValidBST(root->right);
          return left && right;
      }
  };
  ```

  思路：关键在于二叉搜索树的中序遍历是递增的，所以考虑用中序遍历进行递归。用指针指向前一个节点，将前一个节点的值和当前节点进行比较。

### 二叉搜索树的最小绝对值

https://leetcode.cn/problems/minimum-absolute-difference-in-bst/

给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。

差值是一个正数，其数值等于两值之差的绝对值。

```cpp
class Solution
{
public:
    int result = INT_MAX;
    TreeNode *pre = nullptr;
    void traversal(TreeNode *cur)
    {
        if (cur == nullptr)
            return;
        traversal(cur->left);
        if (pre != nullptr)
        {
            result = min(result, cur->val - pre->val);
        }
        pre = cur;
        traversal(cur->right);
    };
    int getMinimumDifference(TreeNode *root)
    {
        traversal(root);
        return result;
    }
};
```

思路：双指针法

### 二叉搜索树中的众数

[501. 二叉搜索树中的众数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/)

给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有 [众数](https://baike.baidu.com/item/众数/44796)（即，出现频率最高的元素）。

如果树中有不止一个众数，可以按 **任意顺序** 返回。

假定 BST 满足如下定义：

- 结点左子树中所含节点的值 **小于等于** 当前节点的值
- 结点右子树中所含节点的值 **大于等于** 当前节点的值
- 左子树和右子树都是二叉搜索树

```cpp
class Solution
{
public:
    int count = 1;
    int maxCount = 0;
    vector<int> result;
    TreeNode *pre;
    void traversal(TreeNode *cur)
    {
        if (cur == nullptr)
            return;
        traversal(cur->left);
        if (pre != nullptr)
        {
            if (pre->val == cur->val)
            {
                count++;
            }
            else
                count = 1;
        }
        pre = cur;
        
        if (count == maxCount)
            result.push_back(cur->val);//必须放在下一个判断条件的上面
        if (count > maxCount)
        {
            maxCount = count;
            result.clear();
            result.push_back(cur->val);
        }//一旦更新了maxcount说明前面记录的值都不是最大的
        traversal(cur->right);
    };
    vector<int> findMode(TreeNode *root)
    {
        traversal(root);
        return result;
    }
};
```

思路：中序遍历，不断更新count与maxcount，每次当count==maxcount就记录，但一旦maxcount有更新就清空前面的无效元素再记录。

### 二叉树的公共祖先

#### 普通二叉树

[236. 二叉树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”



```cpp
class Solution
{
public:


    TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q)
    {
        if (root == nullptr)
        {
            return root;
        }
        if (root == p || root == q)
        {
            return root;
        }
        TreeNode *left = lowestCommonAncestor(root->left, p, q);
        TreeNode *right = lowestCommonAncestor(root->right, p, q);
        if (left!=nullptr&&right!=nullptr)
        {
            return root;
        }
        else if(left==nullptr&&right!=nullptr){
            return right;
        }
        else if(left!=nullptr&&right==nullptr){
            return left;
        }
        else
            return nullptr;
    
    }
};
```

思路：从下往上，找含pq的子树，检查每个节点的左右子树里面是否含有pq，一旦含有，就是最低的公共祖先，往上返回自身，（假设这个节点为其父的左孩子），此时父右孩子还是null，那么就返回这个left孩子作为上一层递归的值（作为left/right），再一层一层地保留。其中的特殊情况是当某个节点的公共节点就是自身的时候，当遇到这种情况，它会直接返回（另一个节点在他下面不会被检查了），然后逐层返回，最后就也是正确地返回了自身。

#### 二叉搜索树

[235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/description/)

```cpp
class Solution {
public:
TreeNode* traversal(TreeNode* cur, TreeNode* p, TreeNode* q){
    if(cur==nullptr){
        return cur;
    }
    if (cur->val>p->val&&cur->val>q->val)
    {
        TreeNode* left=traversal(cur->left,p,q);
        if(left!=nullptr)
            return left;
    }
    if (cur->val<p->val&&cur->val<q->val)
    {
        TreeNode *right = traversal(cur->right, p, q);
        if (right!=nullptr)
        {
            return right;
        }
        
    }
    return cur;//包含了节点本身是公共祖先的情况。
}
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        return traversal(root, p, q);
    }
};
```

思路：公共祖先在数值上有特征！从上往下遍历，找有没有介于pq值之间的节点，一旦找到，根据pq一定在该节点的左右子树之中确定，这个节点就是最近的公共节点。

### 二叉搜索树的插入节点

https://leetcode.cn/problems/insert-into-a-binary-search-tree/

给定二叉搜索树（BST）的根节点 `root` 和要插入树中的值 `value` ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。

```cpp
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (root==nullptr)
        {
            TreeNode *node = new TreeNode(val);
            return node;
        }
        if (val<root->val)
        {
            root->left=insertIntoBST(root->left, val);
        }
        if (val>root->val)
        {
            root->right=insertIntoBST(root->right, val);
        }
        return root;
        }
};
```

一旦节点到null了就是时候创建节点再返回给调用递归函数的父节点。



### 二叉搜索树删除节点

https://leetcode.cn/problems/delete-node-in-a-bst/

给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

1. 首先找到需要删除的节点；
2. 如果找到了，删除它

```cpp
class Solution
{
public:
    TreeNode *deleteNode(TreeNode *root, int key)
    {
        if (root == nullptr)
        {
            return nullptr;
        }
        if (root->val == key)
        {
            if (root->left == nullptr && root->right == nullptr)
            {
                delete root;
                return nullptr;
            }
            else if (root->left != NULL && root->right == nullptr)
            {
                TreeNode *tmp = root;
                root = root->left;
                delete tmp;
                return root;
            }
            else if (root->right != NULL && root->left == nullptr)
            {
                TreeNode *tmp = root;
                root = root->right;
                delete tmp;
                return root;
                
            }
            else
            {
                TreeNode *cur = root->right;
                while (cur->left != nullptr)
                {
                    cur = cur->left;
                }
                cur->left = root->left;
                TreeNode *tmp = root;
                root = root->right;
                delete tmp;
                return root; // 变成左为空右不为空的情况。
            }
        }
        if (key < root->val)
        {
            root->left = deleteNode(root->left, key);
        }
        if (key > root->val)
        {
            root->right = deleteNode(root->right, key);
        }
        return root;
    }
};
```

思路：

先通过递归返回值找到要删除的节点，然后分情况讨论：

1. 左右孩子都为空

   直接返回null给上一层

2. 右为空左不为空

   返回右孩子

3. 左为空右不为空

   返回左孩子

4. 左右都不为空

   把左子树的根节点接到右子树最左侧的叶节点上面，再把右子树的根节点返回给上层。





### 修剪二叉树

[669. 修剪二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/trim-a-binary-search-tree/description/)

给你二叉搜索树的根节点 `root` ，同时给定最小边界`low` 和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。修剪树 **不应该** 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 **唯一的答案** 。

所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变

```cpp
    TreeNode *trimBST(TreeNode *root, int low, int high)
    {
        if (root == nullptr)
        {
            return nullptr;
        }
        if (root->val < low)
        {
            TreeNode *right = trimBST(root->right, low, high);
            return right; // 修右子树
        }
        if (root->val > high)
        {
            TreeNode *left = trimBST(root->left, low, high);
            return left; // 修左子树
        }
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);
        return root;
    }
};
```



### 构造一棵平衡二叉搜索树

[108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/)

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵平衡二叉搜索树。

```cpp
class Solution
{
public:
    TreeNode *traversal(vector<int> &nums, int left, int right) // 左闭右闭
    {
        if (left > right)
        {
            return nullptr;
        }
        int mid = (left + right) / 2;
        TreeNode *root = new TreeNode(nums[mid]);
        root->left = traversal(nums, left, mid - 1);
        root->right = traversal(nums, mid + 1, right);
        return root;
    }
    TreeNode *sortedArrayToBST(vector<int> &nums)
    {
        TreeNode *root = traversal(nums, 0, nums.size() - 1);
        return root;
    }
};
```

注意：递归一定要传引用否则每次递归都是在copy一遍。

平衡二叉搜索树的构造关键在于每次都是从区间里面选取中间的点作为根节点。最重要的是注意下区间开闭！





## 回溯算法

- 组合、切割、子集、排列、棋盘

- 模板：

  ```cpp
  backtracking(参数){
  
  if(终止条件)
  
  	收集结果
  	return;
  for(集合的元素){
      处理节点；
      backtracking()//递归
      回溯//撤销节点处理结果
  }
  return;}
  ```




### 组合问题

[77. 组合 - 力扣（LeetCode）](https://leetcode.cn/problems/combinations/)

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案

```cpp
class Solution
{
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(int n, int k, int startindex)
    {
        if (path.size() == k)
        {
            result.push_back(path);
            return;
        }
        for (int i = startindex; i <= n - (k - path.size()) + 1; i++)
        {

            path.push_back(i);
            backtracking(n, k, i + 1);
            path.pop_back();
        }
    }
    vector<vector<int>> combine(int n, int k)
    {
        result.clear();
        path.clear();
        backtracking(n, k, 1);
        return result;
    }
};
```

思路：每次都只于比自身大的数组合。![77.组合1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195242899.png)

注意剪枝操作，调整范围不用继续向下遍历。

### 组合III

[216. Combination Sum III - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-iii/)

找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：

- 只使用数字1到9
- 每个数字 **最多使用一次** 

返回 *所有可能的有效组合的列表* 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

```cpp
class Solution
{
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(int targetSum, int k, int sum, int startindex)
    {
        if (sum > targetSum)
        {
            return;
        }

        if (path.size() == k)
        {
            if (targetSum == sum)
            {
                result.push_back(path);
            }

            return;
        }
        for (int i = startindex; i <= 10 - (k - path.size()); i++)
        {
            sum += i;
            path.push_back(i);
            backtracking(targetSum, k, sum, i + 1);
            sum -= i;
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum3(int k, int n)
    {
        backtracking(n, k, 0, 1);
        return result;
    }
};
```



### 电话号码的字母组合

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

[17. 电话号码的字母组合 - 力扣（LeetCode）](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/)

```cpp
class Solution
{
public:
    const string letterMap[10] = {
        "", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"} vector<string>;
    vector<string> result;
    string path;
    void backtracking(string &digits, int index,const string&path)
    {
        if (index == digits.size())
        {
            result.push_back(path);
            return;
        }
        int digit = digits[index] - '0';
        string letter = letterMap[digit];
        for (int i = 0; i < letter.size(); i++)
        {
            
            backtracking(digits, index + 1,path+letter[i]);//这步能实现回溯
            

        }
    }
    vector<string> letterCombinations(string digits)
    {
        if (digits.size()==0)
        {
            return result;
        }
        backtracking(digits,0,"");
        return result;
    }
};
```

关键：在递归函数中改变传入的参数来实现回溯。

### 组合总和

[39. 组合总和 - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum/description/)

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

```cpp
class Solution
{
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int> &candidates,int k,int sum,int startindex){
        if (sum>k)
        {
            return; 
        }
        
        if (sum==k)
        {
            result.push_back(path);
            return;
        }
        for (int i = startindex; i < candidates.size()&&sum+candidates[i]<=k; i++)
        {//这要先对candidates进行排序，如果前面小的数的和都已经大于k了，那么后面一定都大于k了，直接结束循环。
            path.push_back(candidates[i]);
            sum += candidates[i];
            backtracking(candidates,k,sum,i);
            sum -= candidates[i];
            path.pop_back();
        }
        
    }
    vector<vector<int>> combinationSum(vector<int> &candidates, int target)
    {
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0);
        
    }
};
```

重点：排序方便剪枝



### 组合总和II

[40. 组合总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-ii/description/)

给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用 **一次** 。

**注意：**解集不能包含重复的组合。 

```cpp
class Solution
{
public:
    vector<vector<int>> result;
    vector<int> path;

    void backtracking(vector<int> &candidates, int target, int startindex, int sum, vector<bool> &used)
    {
        if (sum > target)
        {
            return;
        }
        if (sum == target)
        {
            result.push_back(path);
            return;
        }
        for (int i = startindex; i < candidates.size() && sum + candidates[i] <= target; i++)
        {
            if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false)
            {
                continue;
            }
            path.push_back(candidates[i]);
            sum += candidates[i];
            used[i] = true;
            backtracking(candidates, target, i + 1, sum, used);
            path.pop_back();
            sum -= candidates[i];
            used[i] = false;
        }
    }
    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)
    {
        vector<bool> used(candidates.size(), false);
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0, used);
        return result;
    }
};
```

关键：去重操作。先排序。![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20221021163812.png)

往下层递归取后面重复的元素，是不会产生重复的，但在同一层取重复元素会 产生重复（组合上的重复），所以要用一个数组来明确元素选取状态。如果还在某个元素的树枝里面，设置该元素为true，遇到相同的元素，此时由于该元素已被设置为true，说明不会出现重复，那么就可以使用下面重复的元素。这一树枝结束，该元素设置为false。之后，下一个元素看到前一个元素为false，那么就说明前面相同元素以及走过它的路了，就不要进入for循环了，直接continue去找下一个。

### 分割回文串

[131. 分割回文串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-partitioning/description/)

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 

回文串

 。返回 `s` 所有可能的分割方案。

```cpp
class Solution
{
public:
    vector<string> path;
    vector<vector<string>> result;
    bool isPalindrome(string &s, int startindex, int endindex)
    {
        for (int i = startindex, j = endindex; i < j; i++, j--)
        {
            if (s[i] != s[j])
            {
                return false;
            }
        }
        return true;
    }
    void backtracking(string &s, int startindex)
    {
        if (startindex >= s.size())
        {
            result.push_back(path);
            return;
        }
        for (int i = startindex; i < s.size(); i++)
        {
            if (isPalindrome(s, startindex, i))
            {
                string str = s.substr(startindex, i - startindex + 1);
                path.push_back(str);
            }
            else
            {
                continue;//不是回文就让i往后移动，直到找到回文，往下继续递归。如果没找到，那么就会直接结束，不把这次的path放进result.
            }
            backtracking(s, i + 1);
            path.pop_back();
        }
    }
    vector<vector<string>> partition(string s)
    {
        backtracking(s, 0);
        return result;
    }
};
```

思路：类似于组合问题。往后调整切割位置，直到到末尾终止递归。每次通过切割的startindex确定切割的字串头部，通过i来判断尾部，（因为i会在for循环里不断后移）通过索引判断是否是回文。



### 复原IP地址

**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。

- 例如：`"0.1.2.201"` 和` "192.168.1.1"` 是 **有效** IP 地址，但是 `"0.011.255.245"`、`"192.168.1.312"` 和 `"192.168@1.1"` 是 **无效** IP 地址。

给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。

```cpp
class Solution
{
public:
    vector<string> result;
    
    void backtracking(string &s, int startindex, int pointSum)
    {
        if (pointSum == 3)
        {
            if (IsValid(s, startindex, s.size() - 1))
            {
                result.push_back(s);
            }
            return;
        }
        for (int i = startindex; i < s.size(); i++)
        {
            if (IsValid(s, startindex, i))
            {
                s.insert(s.begin() + i + 1, '.');
                pointSum++;
                backtracking(s, i + 2, pointSum);
                pointSum--;
                s.erase(s.begin() + i + 1);
                
            }
            else break;
        }
    }
    bool IsValid(const string &s, int start, int end)
    {
        if (start > end)
        {
            return false;
        }
        if (s[start] == '0' && start != end)
        {
            return false;
        }
        int num = 0;
        for (int i = start; i <= end; i++)
        {
            if (s[i] > '9' || s[i] < '0') // 遇到非数字字符
            {
                return false;
            }
            num = num * 10 + (s[i] - '0'); // 从高位到低位求原数字
            if (num > 255)
            {
                return false;
            }
        }
        return true;
    }
    vector<string> restoreIpAddresses(string s)
    {
        result.clear();
        if (s.size() < 4 ||s.size() > 12)
        {
            return result;
        }
        backtracking(s, 0, 0);
        return result;
    }
};
```



### 子集

[78. 子集 - 力扣（LeetCode）](https://leetcode.cn/problems/subsets/description/)

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的

子集

（幂集）。



解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    void backtracking(vector<int>& nums,int startindex){
        result.push_back(path);
        if (startindex>nums.size()-1)
        {
            return;
        }
        for (int i = startindex; i < nums.size(); i++)
        {
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
            
        }
        
        
        }
    vector<vector<int>> subsets(vector<int>& nums) {
        backtracking(nums, 0);
        return result;
    }
};
```

每一次都要收集path。

### 子集II

[90. 子集 II - 力扣（LeetCode）](https://leetcode.cn/problems/subsets-ii/)

给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的 子集（幂集）。

解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。

```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    void backtracking(vector<int> &nums, int startindex,vector<bool> used)
    {
        result.push_back(path);
        if (startindex > nums.size() - 1)
        {
            return;
        }
        for (int i = startindex; i < nums.size(); i++)
        {
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false)
            {
                continue;
            }
            path.push_back(nums[i]);
            used[i] = true;
            backtracking(nums, i + 1,used);
            path.pop_back();
            used[i] = false;
        }
    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<bool> used(nums.size(), false);
        sort(nums.begin(), nums.end());
        backtracking(nums, 0, used);
        return result;
    }
};
```

同组合总和II，使用树层去重。

### 非递增子序列

[491. 非递减子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/non-decreasing-subsequences/description/)

给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

```cpp
class Solution
{
public:
    vector<int> path;
    vector<vector<int>> result;
    void backtracking(vector<int> &nums, int startindex)
    {
        if (path.size() > 1)
        {
            result.push_back(path);
        }
        unordered_set<int> uset;//每一层都会创建记录使用情况的uset
        for (int i = startindex; i < nums.size(); i++)
        {
            if (!path.empty()&&nums[i]<path.back()||uset.find(nums[i])!=uset.end())
            {
                continue;
            }
            
            path.push_back(nums[i]);
            uset.insert(nums[i]);
            backtracking(nums,i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> findSubsequences(vector<int> &nums)
    {
        backtracking(nums, 0);
        return result;
    }
};
```

收集结果变成集合里要至少有两个递增元素。



### 排列

[46. 全排列 - 力扣（LeetCode）](https://leetcode.cn/problems/permutations/description/)

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

```cpp
class Solution
{
public:
    vector<int> path;
    vector<vector<int>> result;
    void backtracking(vector<int> &nums, vector<bool> &used)
    {
        if (path.size() == nums.size())
        {
            result.push_back(path);
            return;
        }
        for (int i = 0; i < nums.size(); i++)
        {
            if (used[i] == true)
            {
                continue;
            }
            path.push_back(nums[i]);
            used[i] = true;
            backtracking(nums, used);
            path.pop_back();
            used[i] = false;
        }
    }
    vector<vector<int>> permute(vector<int> &nums)
    {
        vector<bool> used(nums.size(), false);
        backtracking(nums, used);
        return result;
    }
};
```

和组合的区别：不用startindex，而是用used数组来排除使用过的元素。



### 排列II

给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。

[47. 全排列 II - 力扣（LeetCode）](https://leetcode.cn/problems/permutations-ii/description/)

```cpp
class Solution
{
public:
    vector<int> path;
    vector<vector<int>> result;
    void backtracking(vector<int> &nums, vector<bool> &used)
    {
        if (path.size() == nums.size())
        {
            result.push_back(path);
            return;
        }
        for (int i = 0; i < nums.size(); i++)
        {
            if (i>0&&nums[i-1] ==nums[i]&&used[i-1]==false)
            {
                continue;
            }
            if (used[i] == true)
            {
                continue;
            }
            path.push_back(nums[i]);
            used[i] = true;
            backtracking(nums, used);
            path.pop_back();
            used[i] = false;
        }
    }

    vector<vector<int>> permuteUnique(vector<int> &nums)
    {
        vector<bool> used(nums.size(), false);
        sort(nums.begin(), nums.end());
        backtracking(nums, used);
        return result;
    }
};
```

用同一个数组做树层去重。

### N皇后

[51. N 皇后 - 力扣（LeetCode）](https://leetcode.cn/problems/n-queens/description/)

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

```cpp
class Solution
{
public:
    vector<vector<string>> result;
    void backtracking(int n, int row, vector<string> &chessboard)
    {
        if (row == n)
        {
            result.push_back(chessboard);
            return;
        }
        for (int i = 0; i < n; i++)
        {
            if (IsValid(row, i, chessboard,n))
            {
                chessboard[row][i] = 'Q';
                backtracking(n, row + 1, chessboard);
                chessboard[row][i] = '.';
            }
        }
    }
    bool IsValid(int row, int col, vector<string> &chessboard,int n)
    {
        for (int i = 0; i < row; i++)
        {
            if (chessboard[i][col] == 'Q')
            {
                return false;
            }
        }
        for (int i = 0; i < col; i++)
        {
            if (chessboard[row][i] == 'Q')
            {
                return false;
            }
        }
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--)
        {
            if (chessboard[i][j] == 'Q')
            {
                return false;
            }
        }
        for (int i = row - 1, j = col + 1; i >=0 && j <n; i--, j++)
        {
            if (chessboard[i][j] == 'Q')
            {
                return false;
            }
        }
        return true;
    }
    vector<vector<string>> solveNQueens(int n)
    {
        vector<string> chessboard(n, string(n, '.'));
        backtracking(n, 0, chessboard);
        return result;
    }
};
```

难点是这是个二维数组，要想到每次放皇后for循环遍历一行的元素，递归进入下一行，能不能放元素要用个函数判断（因为行数递增，所以只需判断前面行数）

### 解数独

[37. 解数独 - 力扣（LeetCode）](https://leetcode.cn/problems/sudoku-solver/description/)

编写一个程序，通过填充空格来解决数独问题。

数独的解法需 **遵循如下规则**：

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

数独部分空格内已填入了数字，空白格用 `'.'` 表示。

```cpp
class Solution
{
public:
    bool backtracking(vector<vector<char>> &board)
    {
        for (int i = 0; i < board.size(); i++) // 行
        {
            for (int j = 0; j < board[0].size(); j++) // 列
            {
                if (board[i][j] != '.')
                {
                    continue;
                }
                for (char k = '1'; k <= '9'; k++)
                {
                    if (isValid(i, j, k, board))
                    {
                        board[i][j] = k;
                        bool result = backtracking(board);
                        if (result == true)
                        {
                            return true;
                        }
                        board[i][j] = '.';
                    }
                }
                return false;
            }
        }
        return true;
    }
    bool isValid(int row, int col, char val, vector<vector<char>> &board)
    {
        for (int i = 0; i < 9; i++)
        {
            if (board[row][i] == val)
            {
                return false;
            }
        }
        for (int j = 0; j < 9; j++)
        {
            if (board[j][col] == val)
            {
                return false;
            }
        }
        int startRow = (row / 3) * 3;
        int startCol = (col / 3) * 3;
        for (int i = startRow; i < startRow + 3; i++)
        {
            for (int j = startCol; j < startCol + 3; j++)
            {
                if (board[i][j] == val)
                {
                    return false;
                }
            }
        }
        return true;
    }
    void solveSudoku(vector<vector<char>> &board)
    {
        backtracking(board);
    }
};
```

思路：比N皇后问题考虑多一维度。N皇后是每一行只用放一个皇后就可以递归到下一行。但是数独是每一行但凡有空位就要从这个空位出发往后递归往下一个空位放数字.

## 贪心算法

### 分饼干

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是满足尽可能多的孩子，并输出这个最大数值。

[455. 分发饼干 - 力扣（LeetCode）](https://leetcode.cn/problems/assign-cookies/)

```cpp
class Solution {
public://大饼干优先满足胃口大的小孩。
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int index = s.size()-1;
        int result=0;
        for (int i = g.size()-1; i >=0 ; i--)
        {
            if (index>=0&&g[i]<=s[index])
            {
                index--;
                result++;
            }
            
        }
        return result;
        }
};
```

### 摆动序列

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

 [376. 摆动序列 - 力扣（LeetCode）](https://leetcode.cn/problems/wiggle-subsequence/description/)

```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        int curdiff = 0;
        int prediff = 0;
        int result = 1;
        for (int i = 0; i < nums.size()-1; i++)
        {
           curdiff=nums[i+1]-nums[i];
           if (curdiff>0&&prediff<=0||curdiff<0&&prediff>=0)
           {
               result++;
               prediff = curdiff;//pre记录上一个非平坡
           }
           
        }
        return result;
    }
};
```

思路：删除单调坡中间的其他节点，保留两个端点。对于帽子形状有平坡的，算两个。两个元素时，可以想象头部多出来一个和首个元素相同的元素，这样可以算是一个情况。但是对于不是严格单调的平坡情况，我们不能实时更新prediff，而是记录上一次非平坡的情况。

### 最大子序列

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组**是数组中的一个连续部分。

[53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/description/)

```cpp
class Solution
{
public:
    int maxSubArray(vector<int> &nums)
    {
        int result = INT_MIN;
        int count = 0;
        for (int i = 0; i < nums.size(); i++)
        {
            count += nums[i];
            if (count > result)
            {
                result = count;
            }
            if (count < 0)
            {
                count = 0; // 相当于重新选取起始位置。
            }
        }
        return result;
    }
};
```

一旦前面的累计为负数就会拖累后面的数，所以要从新的数重新开始。并不是一遇到负数就重置。

### 买股票

[122. 买卖股票的最佳时机 II - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result=0;
        for (int i = 1; i < prices.size(); i++)
        {
            result += max(prices[i] - prices[i - 1],0);
            
            
        }
        return result;
        }
};
```

思路：由于一次最多能买一支股票，所以买入股票与卖出股票的利润可以拆解为昨天买入今天卖出的利润之和，然后不取负数情况。和上一题的区别：这一题一旦出现负数就不要了，因为不需要连续。

### 跳跃游戏

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

[55. 跳跃游戏 - 力扣（LeetCode）](https://leetcode.cn/problems/jump-game/description/)

```cpp
class Solution
{
public:
    bool canJump(vector<int> &nums)
    {
        int cover = 0;
        if (nums.size() == 1)
        {
            return true;
        }
        for (int i = 0; i <= cover; i++)
        {
            cover = max(i + nums[i], cover);
            if (cover >= nums.size() - 1)
            {
                return true;
            }
        }
        return false;
    }
};
```

考虑覆盖程度。

### 跳跃游戏II

[45. 跳跃游戏 II - 力扣（LeetCode）](https://leetcode.cn/problems/jump-game-ii/description/)

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        if (nums.size()==1)
        {
            return 0;
        }
        int curdistance= 0;
        int nextdistance=0;
        int result = 0;
        for (int i = 0; i < nums.size(); i++)
        {
            nextdistance = max(i + nums[i],nextdistance);
            
            if (i==curdistance)
            {
                if (curdistance!=nums.size()-1)
                {
                    result++;//i=0,肯定会走到这里，所以步数是从1开始。
                    curdistance = nextdistance;
                    if(curdistance>=nums.size()-1)
                        break;
                }
                else{
                    break;
                }
                
            }
            
        }
        return result;
    }
};
```

思路：每次走每个节点的覆盖距离的时候更新下一个节点的最大覆盖距离。不要想着每次都走最大的覆盖距离，可能会跳过更大的覆盖距离。如果走最大的覆盖距离没有到最后位置，那就更新为下一个最大的覆盖距离，步数+1.

### 加油站

[134. 加油站 - 力扣（LeetCode）](https://leetcode.cn/problems/gas-station/description/)

在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。

```cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int cursum = 0;
        int totalSum = 0;
        int start = 0;
        for (int i = 0; i < gas.size(); i++)
        {
            cursum += gas[i] - cost[i];
            totalSum += gas[i] - cost[i];
            if (cursum<0)
            {
                start = i + 1;
                cursum = 0;
            }
            
        }
        if (totalSum<0)
        {
            return -1;
        }
        else{
            return start;
        }
        
    }
};
```

每一个站点作为局部考虑。该站点充油-耗油为下一个到下一个站点的剩余油量。将这个剩余油量做成累加，那么一旦出现负数，就不可能到下一个站点，环不可能从这一点开始，所以，清空累加，从下一个重新开始记。

### 分发糖果

[135. 分发糖果 - 力扣（LeetCode）](https://leetcode.cn/problems/candy/description/)

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

```cpp
class Solution {
public:
    int candy(vector<int>& ratings) {
        vector<int> candyVec(ratings.size(), 1);
        int result=0;
        for (int i = 1; i < ratings.size(); i++)
        {
            if (ratings[i]>ratings[i-1])
            {
                candyVec[i] = candyVec[i-1] + 1;
            }
            
        }
        for (int i = ratings.size()-2; i >=0; i--)
        {
            if (ratings[i]>ratings[i+1])
            {
                candyVec[i] = max(candyVec[i + 1] + 1, candyVec[i]);
            }
            
        }
        for (int i = 0; i < candyVec.size(); i++)
        {
            result += candyVec[i];

        }
        return result;
        }
};
```

思路：为了保持最少糖果，只有当出现更大rating才更新糖果数目。先整体全部比较右边是否大于左边，再整体比较左边是否大于右边。后者不能从前往后遍历，要从后往前。

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20230202102044.png)

### 柠檬水找零

[860. 柠檬水找零 - 力扣（LeetCode）](https://leetcode.cn/problems/lemonade-change/)

在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 `5` 美元、`10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。

注意，一开始你手头没有任何零钱。

给你一个整数数组 `bills` ，其中 `bills[i]` 是第 `i` 位顾客付的账。如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。

```cpp
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int five = 0;
        int ten = 0;
        int twenty = 0;

        for (int bill:bills)
        {
            if (bill==5)
            {
                five++;
            }
            if (bill==10)
            {
                if (five==0)
                {
                    return false;
                }
                
                    ten++;
                    five--;
                
                
            }
            if (bill==20)
            {
                if (ten>0&&five>0)
                {
                    ten--;
                    five--;
                    twenty++;
                }
                else if(five>=3){
                    five -= 3;
                    twenty++;
                }
                else{
                    return false;
                }
            }
            
            
        }
        return true;
    }
};
```

贪心在每次找零钱都是找最大值的。



### 用最少数量的箭引爆气球

[452. 用最少数量的箭引爆气球 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/)

有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。

一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `x``start`，`x``end`， 且满足  `xstart ≤ x ≤ x``end`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。

给你一个数组 `points` ，*返回引爆所有气球所必须射出的 **最小** 弓箭数* 。

```cpp
class Solution
{
public:
    static bool cmp(const vector<int> &a, const vector<int> &b)
    {
        return a[0] < b[0];
    }
    int findMinArrowShots(vector<vector<int>> &points)
    {
        if (points.size() == 0)
        {
            return 0;
        }
        sort(points.begin(), points.end(), cmp);
        int result = 1;
        for (int i = 1; i < points.size(); i++)
        {
            if (points[i][0] > points[i - 1][1])
            {
                result++;
            }
            else
            {
                points[i][1] = min(points[i][1], points[i - 1][1]);
            }
        }
        return result;
    }
};
```

思路：判断气球之间是否重叠，重叠的就用一根箭就可以。判断重复的方法，按照起始位置排序，然后重叠就更新末尾位置（用最短的）

知识点：

**Significance of `static` in this Context:**

1. **Internal Linkage**:

   - Without `static`, the function `cmp` would have **external linkage**, meaning it could be used across different translation units (source files). This would allow other `.cpp` files to call `cmp` if they included the file where it is defined.
   - With `static`, the function is restricted to **internal linkage**, so it can only be used within the file where it is defined. Other files will not be able to directly reference or call `cmp`.

2. **Encapsulation**:

   - By marking `cmp` as `static`, you signal that this comparison function is intended to be used only within the file in which it is defined, and not to be part of the program's external interface. This is useful for encapsulating functionality that does not need to be exposed outside of its current source file.

3. **Compiler Optimization**:

   - The `static` keyword can sometimes assist the compiler in optimizing code, since it guarantees that the function or variable is used only within the translation unit. This can allow for better inlining and other optimizations by the compiler.

     ```cpp
     extern bool cmp(const vector<int>& a, const vector<int>& b); // Error: cmp is not visible here
     
     void anotherFunction() {
         // This will not work because cmp is static in file1.cpp
     }
     
     ```

     

### 无重叠区间

[435. 无重叠区间 - 力扣（LeetCode）](https://leetcode.cn/problems/non-overlapping-intervals/description/)

给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 *需要移除区间的最小数量，使剩余区间互不重叠* 。

**注意** 只在一点上接触的区间是 **不重叠的**。例如 `[1, 2]` 和 `[2, 3]` 是不重叠的。

```cpp
class Solution {
public:
    static bool cmp(const vector<int> &a, const vector<int> &b)
    {
        return a[0] < b[0];
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if (intervals.size() == 0)
        {
            return 0;
        }
        sort(intervals.begin(), intervals.end(), cmp);
        int result = 0;
        for (int i = 1; i < intervals.size(); i++)
        {
            if (intervals[i][0] <intervals[i - 1][1])
            {intervals[i][1] = min(intervals[i][1], intervals[i - 1][1]);
                result++;
            }

        }
        return result;
    }
};
```

重点是为了让删除区间的值最小，那么三个区间重叠在一起要删的是中间的那个，所以每次但凡重叠都要更新末尾位置。

### 合并区间

[56. 合并区间 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-intervals/)

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

```cpp
class Solution
{
public:
    static bool cmp(const vector<int> &a, const vector<int> &b)
    {
        return a[0] < b[0];
    }
    vector<vector<int>> merge(vector<vector<int>> &intervals)
    {
        vector<vector<int>> result;
        if (intervals.size() == 0)
        {
            return result;
        }
        sort(intervals.begin(), intervals.end(), cmp);
        result.push_back(intervals[0]);
        for (int i = 1; i < intervals.size(); i++)
        {
            if (intervals[i][0] <= result.back()[1])
            {
                result.back()[1] = max(result.back()[1], intervals[i][1]);
            }
            else{result.push_back(intervals[i]);}
            
        }return result;
    }
};
```

直接从result里取最新要合并的区间。

### 单调递增的数字

[738. 单调递增的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/monotone-increasing-digits/description/)

当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是**单调递增**的。

给定一个整数 `n` ，返回 *小于或等于 `n` 的最大数字，且数字呈 **单调递增*** 。

 

```cpp
class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        string strNum=to_string(n);
        int flag = strNum.size();//取字符串大小，如果本身就符合条件就不用再赋值9
        for (int i = strNum.size()-1; i >0; i--)
        {
            if (strNum[i-1]>strNum[i])
            {
                flag = i;//用flag是为了防止1000这样的情况，如果是每次改成9，这里是900，但实际上是999
                strNum[i - 1]--;
            }
            
        }
        for (int i = flag; i < strNum.size(); i++)
        {
            strNum[i] = '9';
        }
        return stoi(strNum);
        }
};
```

思路就是每次遇到逆序的，前一位减一，直到

知识点：数字转换为字符串to_string反过来是stoi（），并且他会忽略首位为0。

## 动态规划

解题步骤：

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

### 斐波那契

[509. 斐波那契数 - 力扣（LeetCode）](https://leetcode.cn/problems/fibonacci-number/)

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 `n` ，请计算 `F(n)` 。

```cpp
class Solution {
public:
    int fib(int n) {
        if (n<=1)
        {
            return n;
        }
        
        vector<int>dp(n + 1);
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= n; i++)
        {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
        }
};
```

### 爬楼梯

[70. 爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/climbing-stairs/description/)

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if (n<=1)
        {
            return n;
        }
        vector<int> dp(n + 1);
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++)
        {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
        }
};
```

思路：

dp[i]代表到i阶需要多少种方法。

dp[i-2]走两阶就到dp[i],dp[i-1]走一阶就到dp[i]。

实际上就是斐波那契



### 使用最低花费爬楼梯

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

[746. 使用最小花费爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/min-cost-climbing-stairs/description/)

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        
        vector<int> dp(cost.size());
        dp[0] = cost[0];
        dp[1] = cost[1];
        for (int i = 2; i < cost.size(); i++)
        {
            dp[i] = min(dp[i - 1] , dp[i - 2] )+cost[i];
        }
        return min(dp[cost.size() - 1], dp[cost.size() - 2]);
    }
};
```

每一步的花费都由前两步里花费最小的得来。最后一步理解为不用花费（到数组外一位），只需要返回倒数第一步和倒数第二步最小的就可以了。

### 不同路径

[62. 不同路径 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths/description/)

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

```cpp
class Solution
{
public:
    int uniquePaths(int m, int n)
    {
        vector<vector<int>> dp(m,vector<int>(n,0));
        for (int i = 0; i < m; i++)
        {
            dp[i][0] = 1;
        }
        for (int i = 0; i < n; i++)
        {
            dp[0][i] = 1;
        }
        for (int i = 1; i < m; i++)
        {
            for (int j = 1; j <n; i++)
            {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
            
        }
        return dp[m - 1][n - 1];
    }
};
```

思路：dp数组构建坐标轴。每到一个节点都是从上方或者左边来的。路径数量就是两个的和。初始化走不到的地方（最上面一行和最左边一列）

### 不同路径II

[63. 不同路径 II - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths-ii/)

给定一个 `m x n` 的整数数组 `grid`。一个机器人初始位于 **左上角**（即 `grid[0][0]`）。机器人尝试移动到 **右下角**（即 `grid[m - 1][n - 1]`）。机器人每次只能向下或者向右移动一步。

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。机器人的移动路径中不能包含 **任何** 有障碍物的方格。

返回机器人能够到达右下角的不同路径数量。

测试用例保证答案小于等于 `2 * 10^9`

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>> dp(m,vector<int>(n,0));
        for (int i = 0; i < m&&obstacleGrid[i][0] == 0; i++)
        {
            dp[i][0] = 1;
        }
        for (int i = 0; i < n&&obstacleGrid[0][i] == 0; i++)
        {
            dp[0][i] = 1;
        }
        for (int i = 1; i < m; i++)
        {
            for (int j = 1; j <n; j++)
            {
                if (obstacleGrid[i][j]==1)
                {
                    continue;
                }
                
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
            
        }
        return dp[m - 1][n - 1];

    }
};
```

有障碍的地方通过情况就一直是0，初始化和更新的时候都要注意。

### 整数拆分

[343. 整数拆分 - 力扣（LeetCode）](https://leetcode.cn/problems/integer-break/description/)

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

```cpp
class Solution
{
public:
    int integerBreak(int n)
    {
        vector<int> dp(n+1);//一定要初始化，确保每个位置一开始都是有值的。
        dp[2] = 1;
        for (int i = 3; i <= n; i++)
        {
            for (int j = 1; j < i; j++)
            {
                dp[i] =  max(dp[i], max((i - j) * j, dp[i - j] * j));
            }
            
        }
        return dp[n];
        }
};
```

整数拆分一定是拆成m个接近相等的数才会最大。

每次拆分都可以看成分成两个数和一个数乘另一个数拆分的最大乘积。那么就需要n之前的所有整数都求出最大拆分的乘积。dp[i]是第i个数的最大乘积。

只需要对i-j进行差分处理，因为j的拆分之前已经处理了。

### 不同的二叉搜索树

[96. 不同的二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-binary-search-trees/description/)

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

```cpp
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1);
        dp[0]=1;
        
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= i; j++)
            {
                dp[i] += dp[j - 1] * dp[i - j];
            }
            
        }
        return dp[n];
    }
};
```

![96.不同的二叉搜索树1](https://code-thinking-1253855093.file.myqcloud.com/pics/20210107093129889.png)

3的树的结构由左子树的结构*右子树的结构得来。

左子树：0，右2；左1，右1；左2，右1

### 背包问题

#### 01背包问题

- 二维

1. dp\[i]\[j\]含义：下标为[0.i]物品，放到容量为j的背包。

不放物品i：最大价值就是dp\[i-1][j]

放物品i：dp\[i-1][j-weight[i]]+val[i]

2. dp\[i][j]=max{dp\[i-1][j],dp\[i-1][j-weight[i]]+val[i]}
3. 初始化

![动态规划-背包问题7](https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103109140.png)

初始化最上面一行和最左边一列

其他地方初始化的值不影响，因为本身不会用到。  

两层for循环，如果是二维dp数组实现，可以颠倒物品背包。因为左上方和正上方都有值可以推导。

- 一维

直接把上一层拷贝到在这一层，直接在当前层进行计算

，新的值覆盖在当前层。

1. dp[j]容量为j的背包能装的最大价值

2. dp[j]=max{dp[j],dp[j-weight[i]]+val[i]};
3. 全初始化为0.
4. 遍历顺序

```cpp
for(int i=0;i<物品数量；i++)
	for(int j=bagweight;j>=weight[i];j--)
		dp[j]=max(dp[j],dp[j-weight[i]]+val[i]);
```

   

>  背包价值要倒序遍历确保每个物品只能放一次。
>
> 换了顺序就是会被重复![image-20250917143546850](assets/image-20250917143546850.png)

##### 分割等和子集

[416. 分割等和子集 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-equal-subset-sum/description/)

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

```cpp
class Solution
{
public:
    bool canPartition(vector<int> &nums)
    {
        int sum = 0;
        for (auto num : nums)
        {
            sum += num;
        }
        if (sum % 2 == 1)
            return false;

        int target = sum / 2;
        vector<int> dp(sum + 1, 0);
        for (int i = 0; i < nums.size(); i++)
        {
            for (int j = target; j >= nums[i]; j--)
            {
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
        return dp[target] == target;
    }
};
```

思路：背包容量为总和的一半，看物品能不能刚好装满。重量价值等价。

dp[j]指的是容量为j的最大价值。当dp【target】==target==sum/2

##### 目标和

[494. 目标和 - 力扣（LeetCode）](https://leetcode.cn/problems/target-sum/description/)

给你一个非负整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {

        int left;
        int sum = 0;
        for (auto num : nums)
        {
            sum += num;
        }
        if (abs(target) > sum || (sum + target) % 2 == 1)
        {
            return false;
        }
        
        left = (sum + target) / 2;
        vector<int> dp(left+1,0);
        dp[0] = 1;
        for (int i = 0; i < nums.size(); i++)
        {
            for (int j = left; j>=nums[i] ; j--)
            {
                dp[j] += dp[j - nums[i]];
            }
            
        }
        return dp[left];
        }
};
```

思路：分成加法子集和减法子集，两个子集之和的差为target。两个集合之和的和为sum。left-right=target，left+right=sum，left=（target+sum）/2,不能整除就不存在组合。

现在问题转换为装满left这个容器有多少种方法。

dp[j] 是装满容量为j的背包有多少种方法。

dp[j]由dp[j-nums[i]]推得（就再放个i）

eg：dp[5]=dp[4]+...+dp[1]+dp[0]

dp[j]+=dp[j-nums[i]]

dp[0]=1

最后注意下特殊情况。target绝对值不能比sum更小！这个时候是不合法的，虽然left>0但是实际上是找不到的

##### 一和零

[474. 一和零 - 力扣（LeetCode）](https://leetcode.cn/problems/ones-and-zeroes/description/)

给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m+1,vector<int>(n+1,0));
        for(string str:strs){//遍历物品
            int num1 = 0, num0 = 0;
            for(char c:str){
                if (c=='0')
                {
                    num0++;
                }
                else
                {
                    num1++;
                }
               
                
            }
             for (int i=m; i >=num0; i--)//遍历背包，倒序
                {
                    for (int j = n; j >= num1; j--)
                    {
                        dp[i][j] = max(dp[i][j], dp[i - num0][j - num1] + 1);
                    }
                    
                }
        }
        return dp[m][n];
    }
};
```

思路：两个维度的背包，两个重量都要装。

需要二维dp\[i][j]i个0，j个1的背包最多装了多少物品。

dp\[i][j]=max(dp\[i][j],dp\[i-x][j-y]+1)(x,y是物品里含有的0,1个数)

最后要求的就是dp\[m][n]

dp\[0][0]=0 都初始化为0.



#### 完全背包

一维数组：

一件物品可以使用无限次

```cpp
for(int i=0;i<物品数量；i++)
	for(int j=weight[i];j<=bagweight[i];j++)
		dp[j]=max(dp[j],dp[j-weight[i]]+val[i]);
```

> 正序遍历

两层for循环结果是一样的（列项更新、行向更新），但仅仅针对纯完全背包问题

##### 零钱兑换II

[518. 零钱兑换 II - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change-ii/description/)

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

```cpp
class Solution
{
public:
    int change(int amount, vector<int> &coins)
    {
        vector<uint64_t> dp(amount + 1,0);
        dp[0] = 1;
        for (int i = 0; i < coins.size(); i++)
        {
            for (int j = coins[i]; j <= amount; j++)
            {
                dp[j]+=dp[j-coins[i]];
            }
            
        }
        return dp[amount];
        
    }
};
```

思路：

dp[j]装满容量为j的书包需要多少种方法

最终要求的就是amount。

dp[j]+=dp[j-coins[i]];

dp[0]=1

遍历必须是外层物品内层容量，反过来的话，求的是排列数。

外物品：

|      | 0    | 1    | 2    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 1    | 1    | 1    | 1    | 1    |
| 2    | 1    | 1    | 2    | 2    | 3    |

外容量

|      | 0    | 1    | 2    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 1    | 1    | 1    | 2    | 3    |
| 2    | 1    | 1    | 2    | 3    | 5    |

##### 零钱兑换

[322. 零钱兑换 - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change/description/)

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

```cpp
class Solution
{
public:
    int coinChange(vector<int> &coins, int amount)
    {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i <coins.size(); i++)
        {
            for (int j = coins[i]; j <=amount; j++)
            {
                if (dp[j-coins[i]]!=INT_MAX)//如果dp[j-coins[i]]是初始值则跳过
                {
                    dp[j] = min(dp[j],dp[j-coins[i]]+1);
                }

            }
            
        }
        if (dp[amount]==INT_MAX)
        {
            return -1;
        }
        return dp[amount];
        }
};
```

思路：

dp[j]装满容量为j的背包最少物品数量

要求的是dp[amount]

dp[j]=min(dp[j-cost[i]]+1)

初始化：dp[0]=0,其他的初始化为max。

重要：每次要确保j-cost【i】大于0！



##### 完全平方数

[279. 完全平方数 - 力扣（LeetCode）](https://leetcode.cn/problems/perfect-squares/description/)

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

```cpp
class Solution
{
public:
    int numSquares(int n)
    {
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 1; i * i <= n; i++)
        {
            for (int j = i * i; j <= n; j++)
            {
                if (dp[j - i * i] != INT_MAX)
                {
                    dp[j] = min(dp[j], dp[j - i * i] + 1);
                }
                        }
            if (dp[n] == INT_MAX)
            {
                return -1;
            }
        }
        return dp[n];
    }
};
```

想不到怎么让平方和加和为这个数的同时总数量最小。

实际上就是零钱兑换，实际上就是背包问题。

##### 单词拆分

[139. 单词拆分 - 力扣（LeetCode）](https://leetcode.cn/problems/word-break/description/)

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

```cpp
class Solution
{
public:
    bool wordBreak(string s, vector<string> &wordDict)
    {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for (int i = 0; i <=s.size();i++)
        {
            for (int j = 0; j < i;j++)
            {
                string word = s.substr(j, i - j);
                if (wordSet.find(word) != wordSet.end() && dp[j]==true)
                {
                    dp[i] = true;
                    break;
                }
                
           }
           
        }
        return dp[s.size()];
    }
};
```

创建dp数组，索引是子字符串的长度，内容是判断能否被worddict组成。

递推公式：如果dp[j]==true and substr(i-j)在worddict里面，那么dp[i]=true.

### 买卖股票

#### 买股票的最佳时机

[121. 买卖股票的最佳时机 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/)

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

股票就买卖一次

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(),vector<int>(2,0));
        dp[0][0]=-prices[0];
        dp[0][1]=0;
        for (int i = 1; i < prices.size(); i++)
        {
            dp[i][0]=max(dp[i-1][0],-prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);

        }
        return dp[prices.size()-1][1];
        
    }
};
```

思路：可以用贪心找到左边最小，每次prices[i]-low,找这个最大

用动态规划，考虑每天的两个状态：你持有股票，你不持有股票。

如果你持有股票，可能之前以及有了，也可能是今天才买的。不持有股票可以是之前就不持有，也可以是今天才卖出去的。





#### 买卖股票的最佳时机II

[122. 买卖股票的最佳时机 II - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。可以买卖多次。

返回 *你能获得的 **最大** 利润* 。



```cpp
class Solution
{
public:
    int maxProfit(vector<int> &prices)
    {
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < prices.size(); i++)
        {
            dp[i][0] = max(dp[i - 1][0], dp[i-1][1]-prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[prices.size() - 1][1];
    }
};
```

dp\[i][0] = max(dp\[i - 1][0], dp\[i-1][1]-prices[i]);

和I的区别：在买入股票的前一个状态的金额可以不是0，而是在上一次不持有股票时的金额决定



#### 买卖股票的最佳时机III

[123. 买卖股票的最佳时机 III - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/)

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1:**

```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

```cpp
class Solution
{
public:
    int maxProfit(vector<int> &prices)
    {
        if (prices.size() == 0)
        {
            return 0;
        }
        
        
        vector<vector<int>> dp(prices.size(), vector<int>(5, 0));
        dp[0][1] = -prices[0];
        dp[0][3] = -prices[0];
        for (int i = 1; i < prices.size(); i++)
        {
            dp[i][1]=max(dp[i-1][1],-prices[i]);
            dp[i][2]=max(dp[i-1][2],dp[i-1][1]+prices[i]);
            dp[i][3]=max(dp[i-1][3],dp[i-1][2]-prices[i]);
            dp[i][4]=max(dp[i-1][4],dp[i-1][3]+prices[i]);
        }
        return dp[prices.size()-1][4];
    }
};
```

记录五个状态

0：不操作

1：第一次持有

2：第一次不持有

3：第二次持有

4：第二次不持有

每一天我们都考虑这几种情况。最后要求的的实际上就是状态4，如果2就到了最大，第二次直接在这天买入再卖出就行。

#### 买股票的最佳时机4

给你一个整数数组 `prices` 和一个整数 `k` ，其中 `prices[i]` 是某支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k` 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1：**

```
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```

[188. 买卖股票的最佳时机 IV - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/)

```cpp

class Solution
{
public:
    int maxProfit(int k, vector<int> &prices)
    {
        vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));
        for (int i = 1; i < 2 * k; i += 2)
        {
            dp[0][i] = -prices[0];
        }

        for (int i = 1; i < prices.size(); i++)
        {
            for (int j = 1; j < 2 * k; j += 2)
            {
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] - prices[i]);
                dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] + prices[i]);
            }
        }
        return dp[prices.size() - 1][2 * k];
    }
};
```

III的拓展。

买卖股票的最佳时机含冷冻期

给定一个整数数组`prices`，其中第 `prices[i]` 表示第 `*i*` 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1:**

```
输入: prices = [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
       vector<vector<int>> dp(prices.size(),vector<int>(4,0));
       dp[0][0]=-prices[0];
       for (int i = 1; i < prices.size(); i++)
       {
        dp[i][0]=max(dp[i-1][0],max(dp[i-1][1]-prices[i],dp[i-1][3]-prices[i]));
        dp[i][1]=max(dp[i-1][1],dp[i-1][3]);
        dp[i][2]=dp[i-1][0]+prices[i];
        dp[i][3]=dp[i-1][2];
       }
       return max(dp[prices.size()-1][3],max(dp[prices.size()-1][1],dp[prices.size()-1][2]));
       
    }
};
```

每一天股票的状态不能只看成两种，一种持有，一种不持有。

对于不持有的，需要细分为卖出、保持不持有与冷冻期。

```cpp
dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);
dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
dp[i][2] = dp[i - 1][0] + prices[i];
dp[i][3] = dp[i - 1][2];
```

保持不持有的状态与上一天的冷冻期或保持不持有状态有关。

冷冻期只和上一天卖出有关。

#### 含手续费

给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

###  

**示例 1：**

```
输入：prices = [1, 3, 2, 8, 4, 9], fee = 2
输出：8
```

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < prices.size(); i++)
        {
            dp[i][0] = max(dp[i - 1][0], dp[i-1][1]-prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]-fee);
        }
        return dp[prices.size() - 1][1];
    }
};
```

如果在0状态扣手续费，那么初始化零状态的时候也要扣

状态为1不扣：因为直接看作没买过，否则就会亏钱啊

### 子序列

#### 最长递增子序列

[300. 最长递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-increasing-subsequence/description/)

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的

子序列

。

```cpp
class Solution
{
public:
    int lengthOfLIS(vector<int> &nums)
    {
        vector<int> dp(nums.size(), 1);
        int result = 1;
        
        for (int i = 1; i < nums.size(); i++)
        {
            for (int j = 0; j < i; j++)
            {
                if (nums[i] > nums[j])
                {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            result = max(result, dp[i]);
        }
        return result;
    }
};
```



dp含义：索引为i对应的num[i]的子序列大小。所以最后最长的不是末尾那个数字，要确定结果需要单独考虑。

每次后面数字比前面大，就在前面的基础上加一个

#### 最长连续递增子序列

[674. 最长连续递增序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/)

给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。

**连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。

 

**示例 1：**

```
输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
```

```cpp
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        vector<int> dp(nums.size(), 1);
        int result = 1; 
        
        for (int i = 1; i < nums.size(); i++)
        {
            if (nums[i] > nums[i - 1])
            {
                dp[i] = dp[i - 1] + 1;
            }
            result = max(result, dp[i]);
            
        }
        return result;
    }
};
```

思路：和上一题的区别是少一个内层循环

#### 最长重复子数组

[718. 最长重复子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)



给两个整数数组 `nums1` 和 `nums2` ，返回 *两个数组中 **公共的** 、长度最长的子数组的长度* 。

 

**示例 1：**

```
输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3,2,1] 。
```

```cpp
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        vector<vector<int>> dp (nums1.size() + 1, vector<int>(nums2.size() + 1, 0));
        int result = 0;
        for (int i = 1; i <= nums1.size(); i++) {
            for (int j = 1; j <= nums2.size(); j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                if (dp[i][j] > result) result = dp[i][j];
            }
        }
        return result;
    }
};
```

为啥ij表示上一状态的相等情况？因为初始化直接全部为0就可以，第0时态依赖于-1时态，那么肯定都为0，但如果就是自己，那还要单独初始化。

#### 最长公共子序列

[1143. 最长公共子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-common-subsequence/description/)

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

 

**示例 1：**

```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3
```

```cpp
class Solution
{
public:
    int longestCommonSubsequence(string text1, string text2)
    {
        vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));
        for (int i = 1; i <= text1.size(); i++)
        {
            for (int j = 1; j <= text2.size(); j++)
            {
                if (text1[i - 1] == text2[j - 1])
                {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else
                {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[text1.size()][text2.size()];
    }
};
```

最终结果就是最后一个。





#### 不相交的线

[1035. 不相交的线 - 力扣（LeetCode）](https://leetcode.cn/problems/uncrossed-lines/description/)

在两条独立的水平线上按给定的顺序写下 `nums1` 和 `nums2` 中的整数。

现在，可以绘制一些连接两个数字 `nums1[i]` 和 `nums2[j]` 的直线，这些直线需要同时满足：

-  `nums1[i] == nums2[j]`
- 且绘制的直线不与任何其他连线（非水平线）相交。

请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。

以这种方法绘制线条，并返回可以绘制的最大连线数。

```cpp
和上面一样
```



#### 最大子序列和

[53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/description/)

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。



**子数组**

是数组中的一个连续部分。



 

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 
```

```cpp
class Solution
{
public:
    int maxSubArray(vector<int> &nums)
    {

        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        int result = dp[0];
        for (int i = 1; i < nums.size(); i++)
        {
            dp[i] = max(dp[i - 1] + nums[i], nums[i]);
            result = max(result, dp[i]);
        }
        return result;
    }
};
```

两个状态：要么有前面的子序列延续，要么以自己为起点开始。



#### 判断子序列

[392. 判断子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/is-subsequence/)

给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。

**进阶：**

如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

**致谢：**



**示例 1：**

```
输入：s = "abc", t = "ahbgdc"
输出：true
```

```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
        vector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, 0));
        for (int i = 1; i <= s.size(); i++)
        {
            for (int j = 1; j <= t.size(); j++)
            {
                if (s[i - 1] == t[j - 1])
                {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else
                {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[s.size()][t.size()]==s.size();
    }
};
```

要想到如果存在子序列，那么公共子序列的长度就是s的长度。



#### 不同的子序列长度

[115. 不同的子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/distinct-subsequences/description/)

给你两个字符串 `s` 和 `t` ，统计并返回在 `s` 的 **子序列** 中 `t` 出现的个数，结果需要对 109 + 7 取模。

```
输入：s = "rabbbit", t = "rabbit"
输出：3
解释：
如下所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
rabb bit
rab bbit
rab b bit
```

```cpp
class Solution
{
public:
    int numDistinct(string s, string t)
    {
        vector<vector<uint64_t>> dp(s.size() + 1, vector<uint64_t>(t.size() + 1, 0));
        for (int i = 0; i < s.size(); i++)
        {
            dp[i][0] = 1; // s不为空，t为空，只有一种情况，那就是删了s里所有
        }
        for (int i = 1; i < t.size(); i++)
        {
            dp[0][i] = 0; // t不为空，s为空，不可能
        }

        for (int i = 1; i <= s.size(); i++)
        {
            for (int j = 1; j <= t.size(); j++)
            {
                if (s[i - 1] == t[j - 1])
                {
                   dp[i][j]=dp[i-1][j-1]+dp[i-1][j];//选择要不要删除s[i]
                }
                else
                {
                    dp[i][j]=dp[i-1][j];//删除s[i]
                }
                
                
            }
            
        }
        return dp[s.size()][t.size()];
    }
};
```

dp\[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp\[i][j]。

和求公共子序列的差别：公共那题两个字符串没明确说谁是子序列，所有是两个末尾都可以考虑不要dp\[i][j] = max(dp\[i - 1][j], dp\[i][j - 1]);

但这一题明确了只能删s里的所以是dp\[i][j]=dp\[i-1][j];//删除s[i]

对于i-1于j-1相等

- 例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。也就是考虑删不删s【i】

#### 两个字符串的删除操作

[583. 两个字符串的删除操作 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-operation-for-two-strings/description/)

给定两个单词 `word1` 和 `word2` ，返回使得 `word1` 和 `word2` **相同**所需的**最小步数**。

**每步** 可以删除任意一个字符串中的一个字符。

 

**示例 1：**

```
输入: word1 = "sea", word2 = "eat"
输出: 2
解释: 第一步将 "sea" 变为 "ea" ，第二步将 "eat "变为 "ea"
```

```cpp
class Solution
{
public:
    int minDistance(string word1, string word2)
    {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));
        for (int i = 0; i <= word1.size(); i++)
        {
            dp[i][0] = i;
        }
        for (int i = 0; i <= word2.size(); i++)
        {
            dp[0][i] = i;
        }

        for (int i = 1; i <= word1.size(); i++)
        {
            for (int j = 1; j <= word2.size(); j++)
            {
                if (word1[i - 1] == word2[j - 1])
                {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                else
                {
                    dp[i][j] = min(dp[i - 1][j] + 1, min(dp[i][j - 1] + 1, dp[i - 1][j - 1] + 2));
                } // 但其实这里可以优化，因为dp[i][j-1]就考虑过了dp[i-1][j-1]的情况
            }
            
        }return dp[word1.size()][word2.size()];
    }
};
```

可以直接做，或者最直接用最长公共子序列的方法。

删除其中一个的第i-1位，或者两个都删除。

#### 编辑距离

[72. 编辑距离 - 力扣（LeetCode）](https://leetcode.cn/problems/edit-distance/description/)

给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

 

**示例 1：**

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));
        for (int i = 0; i <= word1.size(); i++)
        {
            dp[i][0] = i;
        }
        for (int i = 0; i <= word2.size(); i++)
        {
            dp[0][i] = i;
        }

        for (int i = 1; i <= word1.size(); i++)
        {
            for (int j = 1; j <= word2.size(); j++)
            {
                if (word1[i - 1] == word2[j - 1])
                {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                else
                {
                    dp[i][j] = min(dp[i - 1][j] + 1, min(dp[i][j - 1] + 1, dp[i - 1][j - 1]+1));//删除或添加操作是等价的
                } 
            }
            
        }return dp[word1.size()][word2.size()];
    }
};
```

递推公式：

1. 删除，那么和上一题一样
2. 插入，等价于删除
3. 替换，相当于dp\[i-1][j-1]再加上一个替换操作，因为替换一定会替换成相同的元素。
