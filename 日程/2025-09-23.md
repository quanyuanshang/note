- [x] 1.算法Bellman题目做
> - dijstras算法解决的最短路径是有向无负边的
> - 因为它默认每次加入新的点路只会增长。
> - 反例：![[Pasted image 20250923134211.png]]
> - Bellman可以有负边但是不能有负回路（和就是没有最小值。对所有边松弛n-1次。
> - 松弛：![[Pasted image 20250923134454.png]]
> - 松弛一次是更新和起点一条边相连的所有节点的最短距离。两次就是两条边相连，至少n-1次就是所有点得最短距离。多于n-1次就是没有变化。
- [x] 2.数据可视化操作学习
> .attr('text-anchor', 'middle');`.attr('text-anchor', 'middle');` 是设置 SVG `<text>` 元素的文本对齐方式。

在 SVG 中，`text-anchor` 属性控制文本相对于给定的 x 坐标的对齐方式：

- `'start'`：文本从 x 坐标开始（默认，左对齐）
- `'middle'`：文本在 x 坐标居中对齐
- `'end'`：文本在 x 坐标右对齐

所以 `.attr('text-anchor', 'middle');` 表示让文本内容在指定的 x 坐标处居中显示。常用于标题或标签居中。

- 设置 `dominant-baseline="middle"`，让文本在 y 方向也居中。
const rects = g.selectAll('rect').data(data).join('rect')

            .attr('fill', 'green').attr('opacity', 0.8)`.join('rect')` 是 D3 v6+ 的数据绑定方法，用于将数据和 SVG 元素（这里是 `<rect>` 矩形）一一对应。
           `.attr('opacity', 0.8)` 是设置 SVG 元素（这里是 `<rect>` 矩形）的透明度属性。

.tween("text", function (d) {

                        let i = d3.interpolate(this.textContent, d.value);

                        return function (t) { this.textContent = formatPercent(i(t)); };

                    })
  - `.tween("text", function (d) { ... })`  
    给每个绑定的数据元素自定义一个名为 `"text"` 的补间动画。  
    `function (d)` 里的 `d` 是当前数据项。
    
- `this.textContent`  
    指的是当前 `<text>` 元素的原始文本内容（比如上一次的数值）。
    
- `d.value`  
    是当前数据项的新值（动画要过渡到的目标值）。
    
- `d3.interpolate(a, b)`  
    创建一个插值器 `i`，可以让数值从 `a` 平滑变化到 `b`。
    
- `return function (t) { ... }`  
    返回的函数会在动画的每一帧被调用，`t` 从 0 到 1，表示动画进度。
    
- `this.textContent = formatPercent(i(t));`  
    在每一帧，把插值器 `i(t)` 的结果格式化后赋值给 `<text>` 元素，实现数字的平滑过渡。

`.attr('id', d => \`rect-${yValue(d)}`)` 的意思是：

- 给每个 `<rect>` 矩形元素设置唯一的 `id` 属性。
- `d` 是当前数据项，`yValue(d)` 通常返回平台名（如 "PS4"、"Switch" 等）。
- 这样每个矩形的 id 就会像 `rect-PS4`、`rect-Switch` 这样唯一命名。

**作用**：  
方便后续用 `d3.select('#rect-PS4')` 这种方式，直接选中某个平台对应的矩形元素，进行样式或动画操作。


在 JavaScript 事件机制里，有一个叫 **事件冒泡 (event bubbling)** 的过程：

- 当你点击某个元素时，事件会先在 **最具体的元素**（比如某个矩形 `<rect>`）触发，
    
- 然后 **一层层向上冒泡**，直到 `<svg>` 甚至 `<body>`、`<html>`。
`e.stopPropagation();` 的意思是 **阻止事件继续冒泡**。

`.attr('dy', yScale.bandwidth() / 2).attr('dx', -10)` 是在设置 SVG `<text>` 元素的**偏移量**，用于微调文本在条形图中的位置。


colorScale.domain(data.map(yValue));

            const sp = d3.scalePoint().domain(data.map(yValue)).range([0, 1]);

            colorScale.range(data.map(d => d3.interpolateSpectral(sp(yValue(d)))));
  这三行代码的作用是：**为每个平台分配一个独特的颜色，并且这些颜色在色谱上均匀分布**，用于条形图的填充色。

详细解释如下：

```javascript
colorScale.domain(data.map(yValue));
const sp = d3.scalePoint().domain(data.map(yValue)).range([0, 1]);
colorScale.range(data.map(d => d3.interpolateSpectral(sp(yValue(d)))));
```

- `colorScale.domain(data.map(yValue));`  
  设置颜色比例尺的输入域（domain），即所有平台的名字。

- `const sp = d3.scalePoint().domain(data.map(yValue)).range([0, 1]);`  
  创建一个点状比例尺（scalePoint），把每个平台均匀映射到 [0, 1] 区间。

- `colorScale.range(data.map(d => d3.interpolateSpectral(sp(yValue(d)))));`  
  对每个平台，计算它在 [0, 1] 区间上的位置，然后用 `d3.interpolateSpectral` 取一个色谱上的颜色，作为该平台的颜色。  
  这样每个平台的颜色都不同，并且色彩分布均匀、美观。

**一句话总结：**  
> 这三行代码让每个平台的条形都有独特且均匀分布的颜色，提升可视化效果。


- [x] 3.听组会
> pipeline
> Point Sam: 通过加点来确定3d中的mask
> 三维点云
> Sonata：几何捷径。三维点每个点都会有自己的位置，导致网络可能在低维度上学习忽略了一些高维的信息。
> - 模糊每个点的空间位置信息
> - 自监督训练encoder，保留丰富信息，没有decoder（可能会抛弃一些信息）
> - 学到更综合的东西
> 
- [x] 4.马克思课程听+互动
> 学期之后再尝试互动吧，先记概念
- [ ] 5.
> 
- [ ] 6.
> 